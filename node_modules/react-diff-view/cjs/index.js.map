{"version":3,"file":"index.js","sources":["../node_modules/classnames/index.js","../src/context/index.js","../src/utils/diff/util.js","../src/utils/diff/factory.js","../node_modules/lodash/_baseFindIndex.js","../node_modules/lodash/_listCacheClear.js","../node_modules/lodash/eq.js","../node_modules/lodash/_assocIndexOf.js","../node_modules/lodash/_listCacheDelete.js","../node_modules/lodash/_listCacheGet.js","../node_modules/lodash/_listCacheHas.js","../node_modules/lodash/_listCacheSet.js","../node_modules/lodash/_ListCache.js","../node_modules/lodash/_stackClear.js","../node_modules/lodash/_stackDelete.js","../node_modules/lodash/_stackGet.js","../node_modules/lodash/_stackHas.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObject.js","../node_modules/lodash/isFunction.js","../node_modules/lodash/_coreJsData.js","../node_modules/lodash/_isMasked.js","../node_modules/lodash/_toSource.js","../node_modules/lodash/_baseIsNative.js","../node_modules/lodash/_getValue.js","../node_modules/lodash/_getNative.js","../node_modules/lodash/_Map.js","../node_modules/lodash/_nativeCreate.js","../node_modules/lodash/_hashClear.js","../node_modules/lodash/_hashDelete.js","../node_modules/lodash/_hashGet.js","../node_modules/lodash/_hashHas.js","../node_modules/lodash/_hashSet.js","../node_modules/lodash/_Hash.js","../node_modules/lodash/_mapCacheClear.js","../node_modules/lodash/_isKeyable.js","../node_modules/lodash/_getMapData.js","../node_modules/lodash/_mapCacheDelete.js","../node_modules/lodash/_mapCacheGet.js","../node_modules/lodash/_mapCacheHas.js","../node_modules/lodash/_mapCacheSet.js","../node_modules/lodash/_MapCache.js","../node_modules/lodash/_stackSet.js","../node_modules/lodash/_Stack.js","../node_modules/lodash/_setCacheAdd.js","../node_modules/lodash/_setCacheHas.js","../node_modules/lodash/_SetCache.js","../node_modules/lodash/_arraySome.js","../node_modules/lodash/_cacheHas.js","../node_modules/lodash/_equalArrays.js","../node_modules/lodash/_Uint8Array.js","../node_modules/lodash/_mapToArray.js","../node_modules/lodash/_setToArray.js","../node_modules/lodash/_equalByTag.js","../node_modules/lodash/_arrayPush.js","../node_modules/lodash/isArray.js","../node_modules/lodash/_baseGetAllKeys.js","../node_modules/lodash/_arrayFilter.js","../node_modules/lodash/stubArray.js","../node_modules/lodash/_getSymbols.js","../node_modules/lodash/_baseTimes.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/_baseIsArguments.js","../node_modules/lodash/isArguments.js","../node_modules/lodash/stubFalse.js","../node_modules/lodash/isBuffer.js","../node_modules/lodash/_isIndex.js","../node_modules/lodash/isLength.js","../node_modules/lodash/_baseIsTypedArray.js","../node_modules/lodash/_baseUnary.js","../node_modules/lodash/_nodeUtil.js","../node_modules/lodash/isTypedArray.js","../node_modules/lodash/_arrayLikeKeys.js","../node_modules/lodash/_isPrototype.js","../node_modules/lodash/_overArg.js","../node_modules/lodash/_nativeKeys.js","../node_modules/lodash/_baseKeys.js","../node_modules/lodash/isArrayLike.js","../node_modules/lodash/keys.js","../node_modules/lodash/_getAllKeys.js","../node_modules/lodash/_equalObjects.js","../node_modules/lodash/_DataView.js","../node_modules/lodash/_Promise.js","../node_modules/lodash/_Set.js","../node_modules/lodash/_WeakMap.js","../node_modules/lodash/_getTag.js","../node_modules/lodash/_baseIsEqualDeep.js","../node_modules/lodash/_baseIsEqual.js","../node_modules/lodash/_baseIsMatch.js","../node_modules/lodash/_isStrictComparable.js","../node_modules/lodash/_getMatchData.js","../node_modules/lodash/_matchesStrictComparable.js","../node_modules/lodash/_baseMatches.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/_isKey.js","../node_modules/lodash/memoize.js","../node_modules/lodash/_memoizeCapped.js","../node_modules/lodash/_stringToPath.js","../node_modules/lodash/_arrayMap.js","../node_modules/lodash/_baseToString.js","../node_modules/lodash/toString.js","../node_modules/lodash/_castPath.js","../node_modules/lodash/_toKey.js","../node_modules/lodash/_baseGet.js","../node_modules/lodash/get.js","../node_modules/lodash/_baseHasIn.js","../node_modules/lodash/_hasPath.js","../node_modules/lodash/hasIn.js","../node_modules/lodash/_baseMatchesProperty.js","../node_modules/lodash/identity.js","../node_modules/lodash/_baseProperty.js","../node_modules/lodash/_basePropertyDeep.js","../node_modules/lodash/property.js","../node_modules/lodash/_baseIteratee.js","../node_modules/lodash/toNumber.js","../node_modules/lodash/toFinite.js","../node_modules/lodash/toInteger.js","../node_modules/lodash/findLastIndex.js","../src/utils/diff/insertHunk.js","../src/utils/diff/expandCollapsedBlockBy.js","../src/utils/diff/getChangeKey.js","../src/utils/diff/index.js","../node_modules/gitdiff-parser/index.js","../src/utils/parse.js","../node_modules/lodash/_defineProperty.js","../node_modules/lodash/_baseAssignValue.js","../node_modules/lodash/_createBaseFor.js","../node_modules/lodash/_baseFor.js","../node_modules/lodash/_baseForOwn.js","../node_modules/lodash/mapValues.js","../src/Hunk/CodeCell.js","../src/Hunk/utils.js","../src/Hunk/UnifiedHunk/UnifiedChange.js","../src/Hunk/UnifiedHunk/UnifiedWidget.js","../src/Hunk/UnifiedHunk/index.js","../src/Hunk/SplitHunk/SplitChange.js","../src/Hunk/SplitHunk/SplitWidget.js","../src/Hunk/SplitHunk/index.js","../src/Hunk/index.js","../src/Diff/index.js","../node_modules/warning/warning.js","../src/Decoration/SplitDecoration.js","../src/Decoration/UnifiedDecoration.js","../src/Decoration/index.js","../node_modules/lodash/_baseCreate.js","../node_modules/lodash/_baseLodash.js","../node_modules/lodash/_LodashWrapper.js","../node_modules/lodash/_isFlattenable.js","../node_modules/lodash/_baseFlatten.js","../node_modules/lodash/flatten.js","../node_modules/lodash/_apply.js","../node_modules/lodash/_overRest.js","../node_modules/lodash/constant.js","../node_modules/lodash/_baseSetToString.js","../node_modules/lodash/_shortOut.js","../node_modules/lodash/_setToString.js","../node_modules/lodash/_flatRest.js","../node_modules/lodash/_metaMap.js","../node_modules/lodash/noop.js","../node_modules/lodash/_getData.js","../node_modules/lodash/_realNames.js","../node_modules/lodash/_getFuncName.js","../node_modules/lodash/_LazyWrapper.js","../node_modules/lodash/_copyArray.js","../node_modules/lodash/_wrapperClone.js","../node_modules/lodash/wrapperLodash.js","../node_modules/lodash/_isLaziable.js","../node_modules/lodash/_createFlow.js","../node_modules/lodash/flow.js","../node_modules/lodash/_arrayAggregator.js","../node_modules/lodash/_createBaseEach.js","../node_modules/lodash/_baseEach.js","../node_modules/lodash/_baseAggregator.js","../node_modules/lodash/_createAggregator.js","../node_modules/lodash/keyBy.js","../node_modules/lodash/last.js","../node_modules/lodash/_baseMap.js","../node_modules/lodash/map.js","../node_modules/lodash/flatMap.js","../src/tokenize/toTokenTrees.js","../node_modules/lodash/_arrayEach.js","../node_modules/lodash/_assignValue.js","../node_modules/lodash/_copyObject.js","../node_modules/lodash/_baseAssign.js","../node_modules/lodash/_nativeKeysIn.js","../node_modules/lodash/_baseKeysIn.js","../node_modules/lodash/keysIn.js","../node_modules/lodash/_baseAssignIn.js","../node_modules/lodash/_cloneBuffer.js","../node_modules/lodash/_copySymbols.js","../node_modules/lodash/_getPrototype.js","../node_modules/lodash/_getSymbolsIn.js","../node_modules/lodash/_copySymbolsIn.js","../node_modules/lodash/_getAllKeysIn.js","../node_modules/lodash/_initCloneArray.js","../node_modules/lodash/_cloneArrayBuffer.js","../node_modules/lodash/_cloneDataView.js","../node_modules/lodash/_cloneRegExp.js","../node_modules/lodash/_cloneSymbol.js","../node_modules/lodash/_cloneTypedArray.js","../node_modules/lodash/_initCloneByTag.js","../node_modules/lodash/_initCloneObject.js","../node_modules/lodash/_baseIsMap.js","../node_modules/lodash/isMap.js","../node_modules/lodash/_baseIsSet.js","../node_modules/lodash/isSet.js","../node_modules/lodash/_baseClone.js","../node_modules/lodash/_baseSlice.js","../node_modules/lodash/_parent.js","../node_modules/lodash/_baseUnset.js","../node_modules/lodash/isPlainObject.js","../node_modules/lodash/_customOmitClone.js","../node_modules/lodash/omit.js","../src/tokenize/utils.js","../src/tokenize/normalizeToLines.js","../node_modules/lodash/isEqual.js","../src/tokenize/backToTree.js","../node_modules/lodash/groupBy.js","../node_modules/lodash/isEmpty.js","../src/tokenize/pickRanges.js","../node_modules/lodash/findIndex.js","../node_modules/diff-match-patch/index.js","../src/tokenize/markEdits.js","../src/tokenize/markWord.js","../src/tokenize/index.js","../node_modules/change-emitter/lib/index.js","../node_modules/symbol-observable/es/index.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/recompose/dist/Recompose.esm.js","../src/hooks/useMinCollapsedLines.js","../src/hooks/helpers.js","../src/hooks/useChangeSelect.js","../src/hooks/useSourceExpansion.js","../node_modules/shallow-equal/objects/index.js","../node_modules/shallow-equal/arrays/index.js","../src/hooks/useTokenizeWorker.js","../src/hocs/withSourceExpansion.js","../src/hocs/minCollapsedLines.js","../src/hocs/withChangeSelect.js","../src/hocs/withTokenizeWorker.js"],"sourcesContent":["/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import {createContext, useContext} from 'react';\n\nconst ContextType = createContext();\nconst {Provider} = ContextType;\nconst useDiffSettings = () => useContext(ContextType);\n\nexport {\n    Provider,\n    useDiffSettings,\n};\n","export const first = array => array[0];\n\nexport const last = array => array[array.length - 1];\n\nexport const sideToProperty = side => [side + 'Start', side + 'Lines'];\n","import {first, last, sideToProperty} from './util';\n\nexport const computeLineNumberFactory = side => {\n    if (side === 'old') {\n        return ({isNormal, isInsert, lineNumber, oldLineNumber}) => {\n            if (isInsert) {\n                return -1;\n            }\n\n            return isNormal ? oldLineNumber : lineNumber;\n        };\n    }\n    return ({isNormal, isDelete, lineNumber, newLineNumber}) => {\n        if (isDelete) {\n            return -1;\n        }\n\n        return isNormal ? newLineNumber : lineNumber;\n    };\n};\n\nexport const isInHunkFactory = (startProperty, linesProperty) => (hunk, lineNumber) => {\n    const start = hunk[startProperty];\n    const end = start + hunk[linesProperty];\n\n    return lineNumber >= start && lineNumber < end;\n};\n\nexport const isBetweenHunksFactory = (startProperty, linesProperty) => (previousHunk, nextHunk, lineNumber) => {\n    const start = previousHunk[startProperty] + previousHunk[linesProperty];\n    const end = nextHunk[startProperty];\n\n    return lineNumber >= start && lineNumber < end;\n};\n\nconst findContainerHunkFactory = side => {\n    const [startProperty, linesProperty] = sideToProperty(side);\n    const isInHunk = isInHunkFactory(startProperty, linesProperty);\n\n    return (hunks, lineNumber) => hunks.find(hunk => isInHunk(hunk, lineNumber));\n};\n\n/* eslint-disable consistent-return */\nexport const findChangeByLineNumberFactory = side => {\n    const computeLineNumber = computeLineNumberFactory(side);\n    const findContainerHunk = findContainerHunkFactory(side);\n\n    return (hunks, lineNumber) => {\n        const containerHunk = findContainerHunk(hunks, lineNumber);\n\n        if (!containerHunk) {\n            return undefined;\n        }\n\n        return containerHunk.changes.find(change => computeLineNumber(change) === lineNumber);\n    };\n};\n/* eslint-enable consistent-return */\n\nexport const getCorrespondingLineNumberFactory = baseSide => {\n    const anotherSide = baseSide === 'old' ? 'new' : 'old';\n    const [baseStart, baseLines] = sideToProperty(baseSide);\n    const [correspondingStart, correspondingLines] = sideToProperty(anotherSide);\n    const baseLineNumber = computeLineNumberFactory(baseSide);\n    const correspondingLineNumber = computeLineNumberFactory(anotherSide);\n    const isInHunk = isInHunkFactory(baseStart, baseLines);\n    const isBetweenHunks = isBetweenHunksFactory(baseStart, baseLines);\n\n    /* eslint-disable complexity */\n    return (hunks, lineNumber) => {\n        const firstHunk = first(hunks);\n\n        // Before first hunk\n        if (lineNumber < firstHunk[baseStart]) {\n            const spanFromStart = firstHunk[baseStart] - lineNumber;\n            return firstHunk[correspondingStart] - spanFromStart;\n        }\n\n        // After last hunk, this can be done in `for` loop, just a quick return path\n        const lastHunk = last(hunks);\n        if (lastHunk[baseStart] + lastHunk[baseLines] <= lineNumber) {\n            const spanFromEnd = lineNumber - lastHunk[baseStart] - lastHunk[baseLines];\n            return lastHunk[correspondingStart] + lastHunk[correspondingLines] + spanFromEnd;\n        }\n\n        for (let i = 0; i < hunks.length; i++) {\n            const currentHunk = hunks[i];\n            const nextHunk = hunks[i + 1];\n\n            // Within current hunk\n            if (isInHunk(currentHunk, lineNumber)) {\n                const changeIndex = currentHunk.changes.findIndex(change => baseLineNumber(change) === lineNumber);\n                const change = currentHunk.changes[changeIndex];\n\n                if (change.isNormal) {\n                    return correspondingLineNumber(change);\n                }\n\n                // For changes of type \"insert\" and \"delete\", the sibling change can be the corresponding one,\n                // or they can have no corresponding change\n                //\n                // Git diff always put delete change before insert change\n                //\n                // Note that `nearbySequences: \"zip\"` option can affect this function\n                const possibleCorrespondingChangeIndex = change.isDelete ? changeIndex + 1 : changeIndex - 1;\n                const possibleCorrespondingChange = currentHunk.changes[possibleCorrespondingChangeIndex];\n\n                if (!possibleCorrespondingChange) {\n                    return -1;\n                }\n\n                const negativeChangeType = change.isInsert ? 'delete' : 'insert';\n\n                return possibleCorrespondingChange.type === negativeChangeType\n                    ? correspondingLineNumber(possibleCorrespondingChange)\n                    : -1;\n            }\n\n            // Between 2 hunks\n            if (isBetweenHunks(currentHunk, nextHunk, lineNumber)) {\n                const spanFromEnd = lineNumber - currentHunk[baseStart] - currentHunk[baseLines];\n                return currentHunk[correspondingStart] + currentHunk[correspondingLines] + spanFromEnd;\n            }\n        }\n\n        /* istanbul ignore next Should not arrive here */\n        throw new Error(`Unexpected line position ${lineNumber}`);\n    };\n    /* eslint-enable complexity */\n};\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * This method is like `_.findIndex` except that it iterates over elements\n * of `collection` from right to left.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=array.length-1] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n * // => 2\n *\n * // The `_.matches` iteratee shorthand.\n * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n * // => 0\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findLastIndex(users, ['active', false]);\n * // => 2\n *\n * // The `_.property` iteratee shorthand.\n * _.findLastIndex(users, 'active');\n * // => 0\n */\nfunction findLastIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = length - 1;\n  if (fromIndex !== undefined) {\n    index = toInteger(fromIndex);\n    index = fromIndex < 0\n      ? nativeMax(length + index, 0)\n      : nativeMin(index, length - 1);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);\n}\n\nmodule.exports = findLastIndex;\n","import {findLastIndex} from 'lodash';\nimport {computeLineNumberFactory} from './factory';\nimport {last} from './util';\n\nconst computeOldLineNumber = computeLineNumberFactory('old');\n\nconst computeNewLineNumber = computeLineNumberFactory('new');\n\nconst getOldRangeFromHunk = ({oldStart, oldLines}) => [oldStart, oldStart + oldLines - 1];\n\nconst createHunkFromChanges = changes => {\n    if (!changes.length) {\n        return null;\n    }\n\n    const initial = {\n        isPlain: true,\n        content: '',\n        oldStart: -1,\n        oldLines: 0,\n        newStart: -1,\n        newLines: 0,\n    };\n    /* eslint-disable no-param-reassign */\n    const hunk = changes.reduce(\n        (hunk, change) => {\n            if (!change.isNormal) {\n                hunk.isPlain = false;\n            }\n\n            if (!change.isInsert) {\n                hunk.oldLines = hunk.oldLines + 1;\n\n                if (hunk.oldStart === -1) {\n                    hunk.oldStart = computeOldLineNumber(change);\n                }\n            }\n\n            if (!change.isDelete) {\n                hunk.newLines = hunk.newLines + 1;\n\n                if (hunk.newStart === -1) {\n                    hunk.newStart = computeNewLineNumber(change);\n                }\n            }\n\n            return hunk;\n        },\n        initial\n    );\n    /* eslint-enable no-param-reassign */\n    const {oldStart, oldLines, newStart, newLines} = hunk;\n\n    return {\n        ...hunk,\n        content: `@@ -${oldStart},${oldLines} +${newStart},${newLines}`,\n        changes: changes,\n    };\n};\n\nexport const textLinesToHunk = (lines, oldStartLineNumber, newStartLineNumber) => {\n    const lineToChange = (line, i) => {\n        return {\n            type: 'normal',\n            isNormal: true,\n            oldLineNumber: oldStartLineNumber + i,\n            newLineNumber: newStartLineNumber + i,\n            content: '' + line,\n        };\n    };\n    const changes = lines.map(lineToChange);\n\n    return createHunkFromChanges(changes);\n};\n\nconst sliceHunk = ({changes}, startOldLineNumber, endOldLineNumber) => {\n    const changeIndex = changes.findIndex(change => computeOldLineNumber(change) >= startOldLineNumber);\n\n    if (changeIndex === -1) {\n        return null;\n    }\n\n    // It is possible to have some insert changes before `startOldLineNumber`,\n    // since we slice from old line number, these changes can be ommited, so we need to grab them back\n    const startIndex = (() => {\n        if (changeIndex === 0) {\n            return changeIndex;\n        }\n\n        const nearestHeadingNocmalChangeIndex = findLastIndex(changes, change => !change.isInsert, changeIndex - 1);\n        return nearestHeadingNocmalChangeIndex === -1 ? changeIndex : nearestHeadingNocmalChangeIndex + 1;\n    })();\n\n    if (endOldLineNumber === undefined) {\n        const slicedChanges = changes.slice(startIndex);\n\n        return createHunkFromChanges(slicedChanges);\n    }\n\n    const endIndex = findLastIndex(changes, change => computeOldLineNumber(change) <= endOldLineNumber);\n    const slicedChanges = changes.slice(startIndex, endIndex === -1 ? undefined : endIndex);\n\n    return createHunkFromChanges(slicedChanges);\n};\n\nconst mergeHunk = (previousHunk, nextHunk) => {\n    if (!previousHunk) {\n        return nextHunk;\n    }\n\n    if (!nextHunk) {\n        return previousHunk;\n    }\n\n    const [previousStart, previousEnd] = getOldRangeFromHunk(previousHunk);\n    const [nextStart, nextEnd] = getOldRangeFromHunk(nextHunk);\n\n    // They are just neighboring, simply concat changes and adjust lines count\n    if (previousEnd + 1 === nextStart) {\n        return createHunkFromChanges([...previousHunk.changes, ...nextHunk.changes]);\n    }\n\n    // It is possible that `previousHunk` entirely **contains** `nextHunk`,\n    // and if we are merging a fake hunk with a valid hunk, we need to replace `nextHunk`'s corresponding range\n    if (previousStart <= nextStart && previousEnd >= nextEnd) {\n        if (previousHunk.isPlain && !nextHunk.isPlain) {\n            const head = sliceHunk(previousHunk, previousStart, nextStart);\n            const tail = sliceHunk(previousHunk, nextEnd + 1);\n            return mergeHunk(mergeHunk(head, nextHunk), tail);\n        }\n\n        return previousHunk;\n    }\n\n    // The 2 hunks have some overlapping, we need to slice the fake one in order to preserve non-normal changes\n    if (previousHunk.isPlain) {\n        const head = sliceHunk(previousHunk, previousStart, nextStart);\n        return mergeHunk(head, nextHunk);\n    }\n\n    const tail = sliceHunk(nextHunk, previousEnd + 1);\n    return mergeHunk(previousHunk, tail);\n};\n\nconst appendOrMergeHunk = (hunks, nextHunk) => {\n    const lastHunk = last(hunks);\n\n    if (!lastHunk) {\n        return [nextHunk];\n    }\n\n    const expectedNextStart = lastHunk.oldStart + lastHunk.oldLines;\n    const actualNextStart = nextHunk.oldStart;\n\n    if (expectedNextStart < actualNextStart) {\n        return hunks.concat(nextHunk);\n    }\n\n    const mergedHunk = mergeHunk(lastHunk, nextHunk);\n\n    return [...hunks.slice(0, -1), mergedHunk];\n};\n\nexport const insertHunk = (hunks, insertion) => {\n    const insertionOldLineNumber = computeOldLineNumber(insertion.changes[0]);\n    const isLaterThanInsertion = ({changes}) => {\n        if (!changes.length) {\n            return false;\n        }\n\n        return computeOldLineNumber(changes[0]) >= insertionOldLineNumber;\n    };\n    const insertPosition = hunks.findIndex(isLaterThanInsertion);\n    const hunksWithInsertion = insertPosition === -1\n        ? hunks.concat(insertion)\n        : [\n            ...hunks.slice(0, insertPosition),\n            insertion,\n            ...hunks.slice(insertPosition),\n        ];\n\n    return hunksWithInsertion.reduce(appendOrMergeHunk, []);\n};\n","import {insertHunk, textLinesToHunk} from './insertHunk';\nimport {\n    computeLineNumberFactory, isInHunkFactory, isBetweenHunksFactory, getCorrespondingLineNumberFactory,\n} from './factory';\nimport {first} from './util';\n\nconst getCorrespondingNewLineNumber = getCorrespondingLineNumberFactory('old');\n\nconst computeOldLineNumber = computeLineNumberFactory('old');\n\nconst isOldLineNumberInHunk = isInHunkFactory('oldStart', 'oldLines');\n\nconst isOldLineNumberBetweenHunks = isBetweenHunksFactory('oldStart', 'oldLines');\n\nconst findCorrespondingValidHunkIndex = (hunks, oldLineNumber) => {\n    if (!hunks.length) {\n        return -1;\n    }\n\n    const firstHunk = first(hunks);\n    if (oldLineNumber < firstHunk.oldStart || isOldLineNumberInHunk(firstHunk, oldLineNumber)) {\n        return 0;\n    }\n\n    for (let i = 1; i < hunks.length; i++) {\n        const currentHunk = hunks[i];\n\n        if (isOldLineNumberInHunk(currentHunk, oldLineNumber)) {\n            return i;\n        }\n\n        const previousHunk = hunks[i - 1];\n\n        if (isOldLineNumberBetweenHunks(previousHunk, currentHunk, oldLineNumber)) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\nconst findNearestNormalChangeIndex = ({changes}, start) => {\n    const index = changes.findIndex(change => computeOldLineNumber(change) === start);\n\n    for (let i = index; i < changes.length; i++) {\n        const change = changes[i];\n\n        if (change.isNormal) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\nconst splitRangeToValidOnes = (hunks, start, end) => {\n    const correspondingHunkIndex = findCorrespondingValidHunkIndex(hunks, start);\n\n    // `start` is after all hunks, we believe all left lines are normal.\n    if (correspondingHunkIndex === -1) {\n        return [[start, end]];\n    }\n\n    const correspondingHunk = hunks[correspondingHunkIndex];\n\n    // If `start` points to a line before this hunk, we collect all heading normal changes\n    if (start < correspondingHunk.oldStart) {\n        const headingChangesCount = correspondingHunk.changes.findIndex(change => !change.isNormal);\n        const validEnd = correspondingHunk.oldStart + Math.max(headingChangesCount, 0);\n\n        if (validEnd >= end) {\n            return [[start, end]];\n        }\n\n        return [\n            [start, validEnd],\n            ...splitRangeToValidOnes(hunks, validEnd + 1, end),\n        ];\n    }\n\n    // Now the `correspondingHunk` must be a hunk containing `start`,\n    // however it is still possible that `start` is not a normal change\n    const {changes} = correspondingHunk;\n    const nearestNormalChangeIndex = findNearestNormalChangeIndex(correspondingHunk, start);\n\n    // If there is no normal changes after `start`, splitting ends up here\n    if (nearestNormalChangeIndex === -1) {\n        return [];\n    }\n\n    const validStartChange = changes[nearestNormalChangeIndex];\n    const validStart = computeOldLineNumber(validStartChange);\n    // Iterate to `end`, if `end` falls out of hunk, we can split it to 2 ranges\n    const adjacentChangesCount = changes.slice(nearestNormalChangeIndex + 1).findIndex(change => !change.isNormal);\n    const validEnd = computeOldLineNumber(validStartChange) + Math.max(adjacentChangesCount, 0);\n\n    if (validEnd >= end) {\n        return [[validStart, end]];\n    }\n\n    return [\n        [validStart, validEnd],\n        ...splitRangeToValidOnes(hunks, validEnd + 1, end),\n    ];\n};\n\nconst expandCodeByValidRange = (hunks, rawCodeOrLines, [start, end]) => {\n    // Note `end` is not inclusive, this is the same as `Array.prototype.slice` method\n    const linesOfCode = typeof rawCodeOrLines === 'string' ? rawCodeOrLines.split('\\n') : rawCodeOrLines;\n    const slicedLines = linesOfCode.slice(Math.max(start, 1) - 1, end - 1);\n\n    if (!slicedLines.length) {\n        return hunks;\n    }\n\n    const slicedHunk = textLinesToHunk(slicedLines, start, getCorrespondingNewLineNumber(hunks, start));\n    return insertHunk(hunks, slicedHunk);\n};\n\nexport const expandFromRawCode = (hunks, rawCodeOrLines, start, end) => {\n    // It is possible to have some insert or delete changes between `start` and `end`,\n    // in order to be 100% safe, we need to split the range to one or more ranges which contains only normal changes.\n    //\n    // For each `start` line number, we can either:\n    //\n    // 1. Find a change and adjust to a nearest normal one.\n    // 2. Find no corresponding change so it must be a collapsed normal change.\n    //\n    // For both cases we can have a starting normal change, then we iterate over its subsequent changes\n    // (line numbers with no corresponding change is considered a normal one)\n    // until an insert or delete is encountered, this is a **valid range**.\n    //\n    // After one valid range is resolved, discard all line numbers related to delete changes, the next normal change\n    // is the start of next valid range.\n    const validRanges = splitRangeToValidOnes(hunks, start, end);\n\n    return validRanges.reduce((hunks, range) => expandCodeByValidRange(hunks, rawCodeOrLines, range), hunks);\n};\n\nexport const getCollapsedLinesCountBetween = (previousHunk, nextHunk) => {\n    if (!previousHunk) {\n        return nextHunk.oldStart - 1;\n    }\n\n    if (!nextHunk) {\n        throw new Error('Unable to compute lines count after the last hunk');\n    }\n\n    const previousEnd = previousHunk.oldStart + previousHunk.oldLines;\n    const nextStart = nextHunk.oldStart;\n\n    return nextStart - previousEnd;\n};\n\nexport const expandCollapsedBlockBy = (hunks, rawCodeOrLines, predicate) => {\n    const linesOfCode = typeof rawCodeOrLines === 'string' ? rawCodeOrLines.split('\\n') : rawCodeOrLines;\n    const firstHunk = first(hunks);\n    const initialExpandingBlocks = predicate(firstHunk.oldStart - 1, 1, 1) ? [[1, firstHunk.oldStart]] : [];\n\n    const expandingBlocks = hunks.reduce(\n        (expandingBlocks, currentHunk, index, hunks) => {\n            const nextHunk = hunks[index + 1];\n            const oldStart = currentHunk.oldStart + currentHunk.oldLines;\n            const newStart = currentHunk.newStart + currentHunk.newLines;\n            const lines = nextHunk\n                ? getCollapsedLinesCountBetween(currentHunk, nextHunk)\n                : linesOfCode.length - oldStart + 1;\n            const shouldExpand = predicate(lines, oldStart, newStart);\n\n            if (shouldExpand) {\n                // initialExpandingBlocks is scoped, it is redundant to copy the array\n                expandingBlocks.push([oldStart, oldStart + lines]);\n            }\n            return expandingBlocks;\n        },\n        initialExpandingBlocks\n    );\n\n    return expandingBlocks.reduce((hunks, [start, end]) => expandFromRawCode(hunks, linesOfCode, start, end), hunks);\n};\n","export const getChangeKey = change => {\n    if (!change) {\n        throw new Error('change is not provided');\n    }\n\n    const {isNormal, isInsert, lineNumber, oldLineNumber} = change;\n\n    if (isNormal) {\n        return 'N' + oldLineNumber;\n    }\n\n    const prefix = isInsert ? 'I' : 'D';\n    return prefix + lineNumber;\n};\n","import {computeLineNumberFactory, findChangeByLineNumberFactory, getCorrespondingLineNumberFactory} from './factory';\n\nexport * from './insertHunk';\nexport * from './expandCollapsedBlockBy';\nexport * from './getChangeKey';\n\nexport const computeOldLineNumber = computeLineNumberFactory('old');\n\nexport const computeNewLineNumber = computeLineNumberFactory('new');\n\nexport const findChangeByOldLineNumber = findChangeByLineNumberFactory('old');\n\nexport const findChangeByNewLineNumber = findChangeByLineNumberFactory('new');\n\nexport const getCorrespondingOldLineNumber = getCorrespondingLineNumberFactory('new');\n\nexport const getCorrespondingNewLineNumber = getCorrespondingLineNumberFactory('old');\n","/**\n * @file gitdiff 消息解析器\n * @author errorrik(errorrik@gmail.com)\n */\n\n(function (root) {\n    var STAT_START = 2;\n    var STAT_FILE_META = 3;\n    var STAT_HUNK = 5;\n\n\n    var parser = {\n        /**\n         * 解析 gitdiff 消息\n         *\n         * @param {string} source gitdiff消息内容\n         * @return {Object}\n         */\n        parse: function (source) {\n            var infos = [];\n            var stat = STAT_START;\n            var currentInfo;\n            var currentHunk;\n            var changeOldLine;\n            var changeNewLine;\n\n\n            var lines = source.split('\\n');\n            var linesLen = lines.length;\n            var i = 0;\n\n            while (i < linesLen) {\n                var line = lines[i];\n\n                if (line.indexOf('diff --git') === 0) {\n                    // read file\n                    currentInfo = {\n                        hunks: [],\n                        oldEndingNewLine: true,\n                        newEndingNewLine: true\n                    };\n\n                    infos.push(currentInfo);\n\n\n                    // 1. 如果oldPath是/dev/null就是add\n                    // 2. 如果newPath是/dev/null就是delete\n                    // 3. 如果有 rename from foo.js 这样的就是rename\n                    // 4. 如果有 copy from foo.js 这样的就是copy\n                    // 5. 其它情况是modify\n                    var currentInfoType = null;\n\n                    // read mode change\n                    var nextLine = lines[i + 1];\n                    if (nextLine.indexOf('old') === 0) {\n                        currentInfo.oldMode = nextLine.slice(9, 16);\n                        currentInfo.newMode = lines[i + 2].slice(9, 16);\n                        i += 2;\n                        nextLine = lines[i + 1];\n                    }\n\n                    // read similarity\n                    if (nextLine.indexOf('similarity') === 0) {\n                        currentInfo.similarity = parseInt(nextLine.split(' ')[2], 10);\n                        i += 1;\n                    }\n\n                    // read type and index\n                    var simiLine;\n                    simiLoop: while ((simiLine = lines[++i])) {\n                        var spaceIndex = simiLine.indexOf(' ');\n                        var infoType = spaceIndex > -1 ? simiLine.slice(0, spaceIndex) : infoType;\n\n                        switch (infoType) {\n                            case 'diff': // diff --git\n                                i--;\n                                break simiLoop;\n\n                            case 'index':\n                                var segs = simiLine.slice(spaceIndex + 1).split(' ');\n                                var revs = segs[0].split('..');\n                                currentInfo.oldRevision = revs[0];\n                                currentInfo.newRevision = revs[1];\n\n                                if (segs[1]) {\n                                    currentInfo.oldMode = currentInfo.newMode = segs[1];\n                                }\n                                break;\n                            \n\n                            case 'copy':\n                            case 'rename':\n                                var infoStr = simiLine.slice(spaceIndex + 1);\n                                if (infoStr.indexOf('from') === 0) {\n                                    currentInfo.oldPath = infoStr.slice(5);\n                                }\n                                else { // rename to\n                                    currentInfo.newPath = infoStr.slice(3);\n                                }\n                                break;\n\n                            case '---':\n                                var oldPath = simiLine.slice(spaceIndex + 1);\n                                var newPath = lines[++i].slice(4); // next line must be \"+++ xxx\"\n                                if (oldPath === '/dev/null') {\n                                    newPath = newPath.slice(2);\n                                    currentInfoType = 'add';\n                                }\n                                else if (newPath === '/dev/null') {\n                                    oldPath = oldPath.slice(2);\n                                    currentInfoType = 'delete';\n                                } else {\n                                    currentInfoType = 'modify';\n                                    oldPath = oldPath.slice(2);\n                                    newPath = newPath.slice(2);\n                                }\n\n                                currentInfo.oldPath = oldPath;\n                                currentInfo.newPath = newPath;\n                                stat = STAT_HUNK;\n                                break simiLoop;\n                        }\n\n                        if (!currentInfoType) {\n                            currentInfoType = infoType;\n                        }\n                    }\n\n                    currentInfo.type = currentInfoType || 'modify';\n                }\n                else if (line.indexOf('Binary') === 0) {\n                    currentInfo.isBinary = true;\n                    currentInfo.type = line.indexOf('/dev/null and') >= 0\n                        ? 'add'\n                        : (line.indexOf('and /dev/null') >= 0 ? 'delete' : 'modify');\n                    stat = STAT_START;\n                    currentInfo = null;\n                }\n                else if (stat === STAT_HUNK) {\n                    if (line.indexOf('@@') === 0) {\n                        var match = /^@@\\s+-([0-9]+)(,([0-9]+))?\\s+\\+([0-9]+)(,([0-9]+))?/.exec(line)\n                        currentHunk = {\n                            content: line,\n                            oldStart: match[1] - 0,\n                            newStart: match[4] - 0,\n                            oldLines: match[3] - 0 || 1,\n                            newLines: match[6] - 0 || 1,\n                            changes: []\n                        };\n\n                        currentInfo.hunks.push(currentHunk);\n                        changeOldLine = currentHunk.oldStart;\n                        changeNewLine = currentHunk.newStart;\n                    }\n                    else {\n                        var typeChar = line.slice(0, 1);\n                        var change = {\n                            content: line.slice(1)\n                        };\n\n                        switch (typeChar) {\n                            case '+':\n                                change.type = 'insert';\n                                change.isInsert = true;\n                                change.lineNumber = changeNewLine;\n                                changeNewLine++;\n                                break;\n\n                            case '-':\n                                change.type = 'delete';\n                                change.isDelete = true;\n                                change.lineNumber = changeOldLine;\n                                changeOldLine++;\n                                break;\n\n                            case ' ':\n                                change.type = 'normal';\n                                change.isNormal = true;\n                                change.oldLineNumber = changeOldLine;\n                                change.newLineNumber = changeNewLine;\n                                changeOldLine++;\n                                changeNewLine++;\n                                break;\n\n                            case '\\\\': // Seems \"no newline\" is the only case starting with /\n                                var lastChange = currentHunk.changes[currentHunk.changes.length - 1];\n                                if (!lastChange.isDelete) {\n                                    currentInfo.newEndingNewLine = false;\n                                }\n                                if (!lastChange.isInsert) {\n                                    currentInfo.oldEndingNewLine = false;\n                                }\n                        }\n\n                        change.type && currentHunk.changes.push(change);\n                    }\n                }\n\n                i++;\n            }\n\n            return infos;\n        }\n    };\n\n    if (typeof exports === 'object' && typeof module === 'object') {\n        // For CommonJS\n        exports = module.exports = parser;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // For AMD\n        define('gitDiffParser', [], parser);\n    }\n    else {\n        root.gitDiffParser = parser;\n    }\n})(this);\n","import parser from 'gitdiff-parser';\n\nconst zipChanges = changes => {\n    const [result] = changes.reduce(\n        ([result, last, lastDeletionIndex], current, i) => {\n            if (!last) {\n                result.push(current);\n                return [result, current, current.isDelete ? i : -1];\n            }\n\n            if (current.isInsert && lastDeletionIndex >= 0) {\n                result.splice(lastDeletionIndex + 1, 0, current);\n                // The new `lastDeletionIndex` may be out of range, but `splice` will fix it\n                return [result, current, lastDeletionIndex + 2];\n            }\n\n            result.push(current);\n\n            // Keep the `lastDeletionIndex` if there are lines of deletions,\n            // otherwise update it to the new deletion line\n            const newLastDeletionIndex = current.isDelete ? (last.isDelete ? lastDeletionIndex : i) : i;\n\n            return [result, current, newLastDeletionIndex];\n        },\n        [[], null, -1]\n    );\n    return result;\n};\n\nconst mapHunk = (hunk, options) => {\n    const changes = options.nearbySequences === 'zip' ? zipChanges(hunk.changes) : hunk.changes;\n\n    return {\n        ...hunk,\n        isPlain: false,\n        changes: changes,\n    };\n};\n\nconst mapFile = (file, options) => {\n    const hunks = file.hunks.map(hunk => mapHunk(hunk, options));\n\n    return {...file, hunks};\n};\n\nconst normalizeDiffText = text => {\n    // Git diff header:\n    //\n    // diff --git a/test/fixture/test/ci.go b/test/fixture/test/ci.go\n    // index 6829b8a2..4c565f1b 100644\n    // --- a/test/fixture/test/ci.go\n    // +++ b/test/fixture/test/ci.go\n    if (text.indexOf('diff --git') === 0) {\n        return text;\n    }\n\n    // Unidiff header:\n    //\n    // --- /test/fixture/test/ci.go 2002-02-21 23:30:39.942229878 -0800\n    // +++ /test/fixture/test/ci.go 2002-02-21 23:30:50.442260588 -0800\n    const indexOfFirstLineBreak = text.indexOf('\\n');\n    const indexOfSecondLineBreak = text.indexOf('\\n', indexOfFirstLineBreak + 1);\n    const firstLine = text.slice(0, indexOfFirstLineBreak);\n    const secondLine = text.slice(indexOfFirstLineBreak + 1, indexOfSecondLineBreak);\n    const oldPath = firstLine.split(' ').slice(1, -3).join(' ');\n    const newPath = secondLine.split(' ').slice(1, -3).join(' ');\n    const segments = [\n        `diff --git a/${oldPath} b/${newPath}`,\n        'index 1111111..2222222 100644',\n        `--- a/${oldPath}`,\n        `+++ b/${newPath}`,\n        text.slice(indexOfSecondLineBreak + 1),\n    ];\n\n    return segments.join('\\n');\n};\n\nexport const parseDiff = (text, options = {}) => {\n    const diffText = normalizeDiffText(text.trim());\n    const files = parser.parse(diffText);\n\n    return files.map(file => mapFile(file, options));\n};\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var baseAssignValue = require('./_baseAssignValue'),\n    baseForOwn = require('./_baseForOwn'),\n    baseIteratee = require('./_baseIteratee');\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n","import {memo} from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\nconst defaultRenderToken = ({type, value, markType, properties, className, children}, i) => {\n    const renderWithClassName = className => (\n        <span key={i} className={className}>\n            {value ? value : (children && children.map(defaultRenderToken))}\n        </span>\n    );\n\n\n    switch (type) {\n        case 'text':\n            return value;\n        case 'mark':\n            return renderWithClassName(`diff-code-mark diff-code-mark-${markType}`);\n        case 'edit':\n            return renderWithClassName('diff-code-edit');\n        default: {\n            // properties normally not exist since it is deconstructed in pickRange, remove in next major release\n            const legacyClassName = properties && properties.className;\n            return renderWithClassName(classNames(className || legacyClassName));\n        }\n    }\n};\n\nconst CodeCell = props => {\n    const {text, tokens, renderToken, ...attributes} = props;\n    const actualRenderToken = renderToken\n        ? (token, i) => renderToken(token, defaultRenderToken, i)\n        : defaultRenderToken;\n\n    return (\n        <td {...attributes}>\n            {\n                tokens\n                    ? (tokens.length ? tokens.map(actualRenderToken) : ' ')\n                    : (text || ' ')\n            }\n        </td>\n    );\n};\n\nCodeCell.propTypes = {\n    text: PropTypes.string.isRequired,\n    tokens: PropTypes.arrayOf(PropTypes.object),\n};\n\nCodeCell.defaultProps = {\n    tokens: null,\n};\n\nexport default memo(CodeCell);\n","import {computeOldLineNumber, computeNewLineNumber} from '../utils';\n\nexport const renderDefaultBy = (change, side) => () => {\n    const lineNumber = side === 'old' ? computeOldLineNumber(change) : computeNewLineNumber(change);\n    return lineNumber === -1 ? undefined : lineNumber;\n};\n\nexport const wrapInAnchorBy = (gutterAnchor, anchorTarget) => element => {\n    if (!gutterAnchor || !element) {\n        return element;\n    }\n\n    return <a href={'#' + anchorTarget}>{element}</a>;\n};\n\nexport const composeCallback = (own, custom) => {\n    if (custom) {\n        return e => {\n            own(e);\n            custom(); // `custom` is already bound with `arg`\n        };\n    }\n\n    return own;\n};\n","/* eslint-disable no-empty-function */\nimport {memo, useState, useMemo, useCallback} from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport {mapValues} from 'lodash';\nimport CodeCell from '../CodeCell';\nimport {composeCallback, renderDefaultBy, wrapInAnchorBy} from '../utils';\n\nconst useBoundCallbacks = (callbacks, arg, hoverOn, hoverOff) => useMemo(\n    () => {\n        const output = mapValues(callbacks, fn => () => fn(arg));\n        output.onMouseEnter = composeCallback(hoverOn, output.onMouseEnter);\n        output.onMouseLeave = composeCallback(hoverOff, output.onMouseLeave);\n        return output;\n    },\n    [callbacks, hoverOn, hoverOff, arg]\n);\n\nconst useBoolean = () => {\n    const [value, setValue] = useState(false);\n    const on = useCallback(() => setValue(true), []);\n    const off = useCallback(() => setValue(false), []);\n    return [value, on, off];\n};\n\nconst renderGutterCell = (className, change, side, gutterAnchor, anchorTarget, events, inHoverState, renderGutter) => {\n    const gutterOptions = {\n        change,\n        side,\n        inHoverState,\n        renderDefault: renderDefaultBy(change, side),\n        wrapInAnchor: wrapInAnchorBy(gutterAnchor, anchorTarget),\n    };\n\n    return (\n        <td className={className} {...events}>\n            {renderGutter(gutterOptions)}\n        </td>\n    );\n};\n\nconst UnifiedChange = props => {\n    const {\n        change,\n        selected,\n        tokens,\n        className,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        hideGutter,\n        gutterAnchor,\n        generateAnchorID,\n        renderToken,\n        renderGutter,\n    } = props;\n    const {type, content} = change;\n\n    const [hover, hoverOn, hoverOff] = useBoolean();\n    const eventArg = useMemo(() => ({change}), [change]);\n    const boundGutterEvents = useBoundCallbacks(gutterEvents, eventArg, hoverOn, hoverOff);\n    const boundCodeEvents = useBoundCallbacks(codeEvents, eventArg, hoverOn, hoverOff);\n\n    const anchorID = generateAnchorID(change);\n    const gutterClassNameValue = classNames(\n        'diff-gutter',\n        `diff-gutter-${type}`,\n        gutterClassName,\n        {'diff-gutter-selected': selected}\n    );\n    const codeClassNameValue = classNames(\n        'diff-code',\n        `diff-code-${type}`,\n        codeClassName,\n        {'diff-code-selected': selected}\n    );\n\n    return (\n        <tr id={anchorID} className={classNames('diff-line', className)}>\n            {\n                !hideGutter && renderGutterCell(\n                    gutterClassNameValue,\n                    change,\n                    'old',\n                    gutterAnchor,\n                    anchorID,\n                    boundGutterEvents,\n                    hover,\n                    renderGutter\n                )\n            }\n            {\n                !hideGutter && renderGutterCell(\n                    gutterClassNameValue,\n                    change,\n                    'new',\n                    gutterAnchor,\n                    anchorID,\n                    boundGutterEvents,\n                    hover,\n                    renderGutter\n                )\n            }\n            <CodeCell\n                className={codeClassNameValue}\n                text={content}\n                tokens={tokens}\n                renderToken={renderToken}\n                {...boundCodeEvents}\n            />\n        </tr>\n    );\n};\n\n\nUnifiedChange.propTypes = {\n    selected: PropTypes.bool.isRequired,\n    tokens: PropTypes.arrayOf(PropTypes.object),\n};\n\nUnifiedChange.defaultProps = {\n    tokens: null,\n};\n\nexport default memo(UnifiedChange);\n","const UnifiedWidget = ({hideGutter, element}) => (\n    <tr className=\"diff-widget\">\n        <td colSpan={hideGutter ? 1 : 3} className=\"diff-widget-content\">\n            {element}\n        </td>\n    </tr>\n);\n\nexport default UnifiedWidget;\n","import classNames from 'classnames';\nimport {getChangeKey, computeOldLineNumber, computeNewLineNumber} from '../../utils';\nimport UnifiedChange from './UnifiedChange';\nimport UnifiedWidget from './UnifiedWidget';\n\nconst groupElements = (changes, widgets) => changes.reduce(\n    (elements, change) => {\n        const key = getChangeKey(change);\n\n        elements.push(['change', key, change]);\n\n        const widget = widgets[key];\n\n        if (widget) {\n            elements.push(['widget', key, widget]);\n        }\n\n        return elements;\n    },\n    []\n);\n\nconst renderRow = ([type, key, value], props) => {\n    const {hideGutter, selectedChanges, tokens, lineClassName, ...changeProps} = props;\n\n    if (type === 'change') {\n        const side = value.isDelete ? 'old' : 'new';\n        const lineNumber = value.isDelete ? computeOldLineNumber(value) : computeNewLineNumber(value);\n        const tokensOfLine = tokens ? tokens[side][lineNumber - 1] : null;\n\n        return (\n            <UnifiedChange\n                key={`change${key}`}\n                className={lineClassName}\n                change={value}\n                hideGutter={hideGutter}\n                selected={selectedChanges.includes(key)}\n                tokens={tokensOfLine}\n                {...changeProps}\n            />\n        );\n    }\n    else if (type === 'widget') {\n        return <UnifiedWidget key={`widget${key}`} hideGutter={hideGutter} element={value} />;\n    }\n\n    return null;\n};\n\nconst UnifiedHunk = props => {\n    const {\n        hunk,\n        widgets,\n        className,\n        ...childrenProps\n    } = props;\n    const elements = groupElements(hunk.changes, widgets);\n\n    return (\n        <tbody className={classNames('diff-hunk', className)}>\n            {elements.map(element => renderRow(element, childrenProps))}\n        </tbody>\n    );\n};\n\nexport default UnifiedHunk;\n","/* eslint-disable no-empty-function */\nimport {memo, useState, useMemo, useCallback} from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport {mapValues} from 'lodash';\nimport CodeCell from '../CodeCell';\nimport {composeCallback, renderDefaultBy, wrapInAnchorBy} from '../utils';\n\nconst SIDE_OLD = 0;\nconst SIDE_NEW = 1;\n\nconst useCallbackOnSide = (side, setHover, change, customCallbacks) => {\n    const markHover = useCallback(() => setHover(side), [side, setHover]);\n    const unmarkHover = useCallback(() => setHover(''), [setHover]);\n    // Unlike selectors, hooks do not provide native functionality to customize comparator,\n    // on realizing that this does not reduce amount of renders, only preventing duplicate merge computations,\n    // we decide not to optimize this extremely, leave it recomputed on certain rerenders.\n    const callbacks = useMemo(\n        () => {\n            const callbacks = mapValues(customCallbacks, fn => () => fn({side, change}));\n            callbacks.onMouseEnter = composeCallback(markHover, callbacks.onMouseEnter);\n            callbacks.onMouseLeave = composeCallback(unmarkHover, callbacks.onMouseLeave);\n            return callbacks;\n        },\n        [change, customCallbacks, markHover, side, unmarkHover]\n    );\n    return callbacks;\n};\n\nconst renderCells = args => {\n    const {\n        change,\n        side,\n        selected,\n        tokens,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        anchorID,\n        gutterAnchor,\n        gutterAnchorTarget,\n        hideGutter,\n        hover,\n        renderToken,\n        renderGutter,\n    } = args;\n\n    if (!change) {\n        const gutterClassNameValue = classNames('diff-gutter', 'diff-gutter-omit', gutterClassName);\n        const codeClassNameValue = classNames('diff-code', 'diff-code-omit', codeClassName);\n\n        return [\n            !hideGutter && <td key=\"gutter\" className={gutterClassNameValue} />,\n            <td key=\"code\" className={codeClassNameValue} />,\n        ];\n    }\n\n    const {type, content} = change;\n    const sideName = side === SIDE_OLD ? 'old' : 'new';\n    const gutterClassNameValue = classNames(\n        'diff-gutter',\n        `diff-gutter-${type}`,\n        {\n            'diff-gutter-selected': selected,\n            ['diff-line-hover-' + sideName]: hover,\n        },\n        gutterClassName\n    );\n    const gutterOptions = {\n        change,\n        side: sideName,\n        inHoverState: hover,\n        renderDefault: renderDefaultBy(change, sideName),\n        wrapInAnchor: wrapInAnchorBy(gutterAnchor, gutterAnchorTarget),\n    };\n    const gutterProps = {\n        id: anchorID,\n        className: gutterClassNameValue,\n        children: renderGutter(gutterOptions),\n        ...gutterEvents,\n    };\n    const codeClassNameValue = classNames(\n        'diff-code',\n        `diff-code-${type}`,\n        {\n            'diff-code-selected': selected,\n            ['diff-line-hover-' + sideName]: hover,\n        },\n        codeClassName\n    );\n\n    return [\n        !hideGutter && <td key=\"gutter\" {...gutterProps} />,\n        <CodeCell\n            key=\"code\"\n            className={codeClassNameValue}\n            text={content}\n            tokens={tokens}\n            renderToken={renderToken}\n            {...codeEvents}\n        />,\n    ];\n};\n\nconst SplitChange = props => {\n    const {\n        className,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        oldChange,\n        newChange,\n        oldSelected,\n        newSelected,\n        oldTokens,\n        newTokens,\n        monotonous,\n        hideGutter,\n        generateAnchorID,\n        gutterAnchor,\n        renderToken,\n        renderGutter,\n    } = props;\n\n    const [hover, setHover] = useState('');\n    const oldGutterEvents = useCallbackOnSide('old', setHover, oldChange, gutterEvents);\n    const newGutterEvents = useCallbackOnSide('new', setHover, newChange, gutterEvents);\n    const oldCodeEvents = useCallbackOnSide('old', setHover, oldChange, codeEvents);\n    const newCodeEvents = useCallbackOnSide('new', setHover, newChange, codeEvents);\n    const oldAnchorID = oldChange && generateAnchorID(oldChange);\n    const newAnchorID = newChange && generateAnchorID(newChange);\n    const commons = {\n        monotonous,\n        hideGutter,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        renderToken,\n        renderGutter,\n    };\n    const oldArgs = {\n        ...commons,\n        change: oldChange,\n        side: SIDE_OLD,\n        selected: oldSelected,\n        tokens: oldTokens,\n        gutterEvents: oldGutterEvents,\n        codeEvents: oldCodeEvents,\n        anchorID: oldAnchorID,\n        gutterAnchor: gutterAnchor,\n        gutterAnchorTarget: oldAnchorID,\n        hover: hover === 'old',\n    };\n    const newArgs = {\n        ...commons,\n        change: newChange,\n        side: SIDE_NEW,\n        selected: newSelected,\n        tokens: newTokens,\n        gutterEvents: newGutterEvents,\n        codeEvents: newCodeEvents,\n        anchorID: oldChange === newChange ? undefined : newAnchorID,\n        gutterAnchor: gutterAnchor,\n        gutterAnchorTarget: oldChange === newChange ? oldAnchorID : newAnchorID,\n        hover: hover === 'new',\n    };\n\n    if (monotonous) {\n        return (\n            <tr className={classNames('diff-line', className)}>\n                {renderCells(oldChange ? oldArgs : newArgs)}\n            </tr>\n        );\n    }\n\n    const lineTypeClassName = ((oldChange, newChange) => {\n        if (oldChange && !newChange) {\n            return 'diff-line-old-only';\n        }\n\n        if (!oldChange && newChange) {\n            return 'diff-line-new-only';\n        }\n\n        if (oldChange === newChange) {\n            return 'diff-line-normal';\n        }\n\n        return 'diff-line-compare';\n    })(oldChange, newChange);\n\n    return (\n        <tr className={classNames('diff-line', lineTypeClassName, className)}>\n            {renderCells(oldArgs)}\n            {renderCells(newArgs)}\n        </tr>\n    );\n};\n\n\nSplitChange.propTypes = {\n    oldSelected: PropTypes.bool.isRequired,\n    newSelected: PropTypes.bool.isRequired,\n    oldTokens: PropTypes.arrayOf(PropTypes.object),\n    newTokens: PropTypes.arrayOf(PropTypes.object),\n};\n\nSplitChange.defaultProps = {\n    oldTokens: null,\n    newTokens: null,\n};\n\nexport default memo(SplitChange);\n","const SplitWidget = ({oldElement, newElement, monotonous, hideGutter}) => {\n    if (monotonous) {\n        return (\n            <tr className=\"diff-widget\">\n                <td colSpan={hideGutter ? 1 : 2} className=\"diff-widget-content\">\n                    {oldElement || newElement}\n                </td>\n            </tr>\n        );\n    }\n\n    if (oldElement === newElement) {\n        return (\n            <tr className=\"diff-widget\">\n                <td colSpan={hideGutter ? 2 : 4} className=\"diff-widget-content\">\n                    {oldElement}\n                </td>\n            </tr>\n        );\n    }\n\n    return (\n        <tr className=\"diff-widget\">\n            <td colSpan={hideGutter ? 1 : 2} className=\"diff-widget-content\">\n                {oldElement}\n            </td>\n            <td colSpan={hideGutter ? 1 : 2} className=\"diff-widget-content\">\n                {newElement}\n            </td>\n        </tr>\n    );\n};\n\nexport default SplitWidget;\n","import classNames from 'classnames';\nimport {getChangeKey, computeOldLineNumber, computeNewLineNumber} from '../../utils';\nimport SplitChange from './SplitChange';\nimport SplitWidget from './SplitWidget';\n\nconst keyForPair = (x, y) => {\n    const keyForX = x ? getChangeKey(x) : '00';\n    const keyForY = y ? getChangeKey(y) : '00';\n    return keyForX + keyForY;\n};\n\nconst groupElements = (changes, widgets) => {\n    const findWidget = change => {\n        if (!change) {\n            return null;\n        }\n\n        const key = getChangeKey(change);\n        return widgets[key] || null;\n    };\n    const elements = [];\n\n    // This could be a very complex reduce call, use `for` loop seems to make it a little more readable\n    for (let i = 0; i < changes.length; i++) {\n        const current = changes[i];\n\n        // A normal change is displayed on both side\n        if (current.isNormal) {\n            elements.push(['change', keyForPair(current, current), current, current]);\n        }\n        else if (current.isDelete) {\n            const next = changes[i + 1];\n            // If an insert change is following a elete change, they should be displayed side by side\n            if (next && next.isInsert) {\n                i = i + 1;\n                elements.push(['change', keyForPair(current, next), current, next]);\n            }\n            else {\n                elements.push(['change', keyForPair(current, null), current, null]);\n            }\n        }\n        else {\n            elements.push(['change', keyForPair(null, current), null, current]);\n        }\n\n        const rowChanges = elements[elements.length - 1];\n        const [oldWidget, newWidget] = rowChanges.slice(2).map(findWidget);\n        if (oldWidget || newWidget) {\n            const key = rowChanges[1];\n            elements.push(['widget', key, oldWidget, newWidget]);\n        }\n    }\n\n    return elements;\n};\n\nconst renderRow = ([type, key, oldValue, newValue], props) => {\n    const {\n        selectedChanges,\n        monotonous,\n        hideGutter,\n        tokens,\n        lineClassName,\n        ...changeProps\n    } = props;\n\n    if (type === 'change') {\n        const oldSelected = oldValue ? selectedChanges.includes(getChangeKey(oldValue)) : false;\n        const newSelected = newValue ? selectedChanges.includes(getChangeKey(newValue)) : false;\n        const oldTokens = (oldValue && tokens) ? tokens.old[computeOldLineNumber(oldValue) - 1] : null;\n        const newTokens = (newValue && tokens) ? tokens.new[computeNewLineNumber(newValue) - 1] : null;\n\n        return (\n            <SplitChange\n                key={`change${key}`}\n                className={lineClassName}\n                oldChange={oldValue}\n                newChange={newValue}\n                monotonous={monotonous}\n                hideGutter={hideGutter}\n                oldSelected={oldSelected}\n                newSelected={newSelected}\n                oldTokens={oldTokens}\n                newTokens={newTokens}\n                {...changeProps}\n            />\n        );\n    }\n    else if (type === 'widget') {\n        return (\n            <SplitWidget\n                key={`widget${key}`}\n                monotonous={monotonous}\n                hideGutter={hideGutter}\n                oldElement={oldValue}\n                newElement={newValue}\n            />\n        );\n    }\n\n    return null;\n};\n\nconst SplitHunk = props => {\n    const {\n        hunk,\n        widgets,\n        className,\n        ...childrenProps\n    } = props;\n    const elements = groupElements(hunk.changes, widgets);\n\n    return (\n        <tbody className={classNames('diff-hunk', className)}>\n            {elements.map(item => renderRow(item, childrenProps))}\n        </tbody>\n    );\n};\n\nexport default SplitHunk;\n","import PropTypes from 'prop-types';\nimport {useDiffSettings} from '../context';\nimport UnifiedHunk from './UnifiedHunk';\nimport SplitHunk from './SplitHunk';\n\nconst Hunk = ({hunk, className, ...props}) => {\n    const {gutterType, ...context} = useDiffSettings();\n    const hideGutter = gutterType === 'none';\n    const gutterAnchor = gutterType === 'anchor';\n    const RenderingHunk = context.viewType === 'unified' ? UnifiedHunk : SplitHunk;\n\n    return (\n        <RenderingHunk\n            {...context}\n            {...props}\n            hunk={hunk}\n            hideGutter={hideGutter}\n            gutterAnchor={gutterAnchor}\n            className={className}\n        />\n    );\n};\n\nHunk.propTypes = (() => {\n    const change = {\n        type: PropTypes.oneOf(['delete', 'insert', 'normal']).isRequired,\n        content: PropTypes.string.isRequired,\n        isNormal: PropTypes.bool,\n        isInsert: PropTypes.bool,\n        isDelete: PropTypes.bool,\n        lineNumber: PropTypes.number,\n        oldLineNumber: PropTypes.number,\n        newLineNumber: PropTypes.number,\n    };\n\n    const hunk = {\n        oldStart: PropTypes.number.isRequired,\n        oldLines: PropTypes.number.isRequired,\n        newStart: PropTypes.number.isRequired,\n        newLines: PropTypes.number.isRequired,\n        content: PropTypes.string.isRequired,\n        changes: PropTypes.arrayOf(PropTypes.shape(change)).isRequired,\n    };\n\n    return {\n        hunk: PropTypes.shape(hunk).isRequired,\n        className: PropTypes.string,\n        lineClassName: PropTypes.string,\n        gutterClassName: PropTypes.string,\n        contentClassName: PropTypes.string,\n        gutterEvents: PropTypes.object,\n        codeEvents: PropTypes.object,\n    };\n})();\n\nHunk.defaultProps = {\n    className: '',\n    lineClassName: '',\n    gutterClassName: '',\n    contentClassName: '',\n    gutterEvents: {},\n    codeEvents: {},\n};\n\nexport default Hunk;\n","import {memo, useRef, useCallback} from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport {Provider} from '../context';\nimport Hunk from '../Hunk';\n\nconst noop = () => {}; // eslint-disable-line no-empty-function\n\nconst findClosest = (target, className) => {\n    while (target && target !== document && !target.classList.contains(className)) {\n        target = target.parentNode; // eslint-disable-line no-param-reassign\n    }\n\n    return target === document ? null : target;\n};\n\nconst setUserSelectStyle = (element, selectable) => {\n    const value = selectable ? 'auto' : 'none';\n\n    if (element.style.userSelect !== value) {\n        element.style.userSelect = value; // eslint-disable-line no-param-reassign\n    }\n};\n\nconst Diff = props => {\n    const root = useRef(null);\n    const enableColumnSelection = useCallback(\n        ({target, button}) => {\n            if (button !== 0) {\n                return;\n            }\n\n            const closestCell = findClosest(target, 'diff-code');\n\n            if (!closestCell) {\n                return;\n            }\n\n            window.getSelection().removeAllRanges();\n\n            const index = [...closestCell.parentNode.children].indexOf(closestCell);\n\n            if (index !== 1 && index !== 3) {\n                return;\n            }\n\n            const lines = root.current.querySelectorAll('.diff-line');\n            for (const line of lines) {\n                const cells = line.children;\n                setUserSelectStyle(cells[1], index === 1);\n                setUserSelectStyle(cells[3], index === 3);\n            }\n        },\n        []\n    );\n\n    const {diffType, children, className, optimizeSelection, hunks, ...remainings} = props;\n    const {gutterType, viewType} = remainings;\n    const hideGutter = gutterType === 'none';\n    const monotonous = diffType === 'add' || diffType === 'delete';\n    const onTableMouseDown = (viewType === 'split' && !monotonous && optimizeSelection) ? enableColumnSelection : noop;\n    const cols = ((viewType, monotonous) => {\n        if (viewType === 'unified') {\n            return (\n                <colgroup>\n                    {!hideGutter && <col className=\"diff-gutter-col\" />}\n                    {!hideGutter && <col className=\"diff-gutter-col\" />}\n                    <col />\n                </colgroup>\n            );\n        }\n\n        if (monotonous) {\n            return (\n                <colgroup>\n                    {!hideGutter && <col className=\"diff-gutter-col\" />}\n                    <col />\n                </colgroup>\n            );\n        }\n\n        return (\n            <colgroup>\n                {!hideGutter && <col className=\"diff-gutter-col\" />}\n                <col />\n                {!hideGutter && <col className=\"diff-gutter-col\" />}\n                <col />\n            </colgroup>\n        );\n    })(props.viewType, monotonous);\n\n    return (\n        <Provider value={{...remainings, monotonous}}>\n            <table\n                ref={root}\n                className={classNames('diff', `diff-${viewType}`, className)}\n                onMouseDown={onTableMouseDown}\n            >\n                {cols}\n                {children(hunks)}\n            </table>\n        </Provider>\n    );\n};\n\nDiff.propTypes = {\n    diffType: PropTypes.oneOf(['add', 'delete', 'modify', 'rename', 'copy']).isRequired,\n    viewType: PropTypes.oneOf(['unified', 'split']).isRequired,\n    hunks: PropTypes.arrayOf(PropTypes.object).isRequired,\n    gutterType: PropTypes.oneOf(['default', 'none', 'anchor']),\n    generateAnchorID: PropTypes.func,\n    selectedChanges: PropTypes.arrayOf(PropTypes.string),\n    widgets: PropTypes.objectOf(PropTypes.node),\n    optimizeSelection: PropTypes.bool,\n    className: PropTypes.string,\n    renderToken: PropTypes.func,\n    renderGutter: PropTypes.func,\n    children: PropTypes.func,\n};\n\nDiff.defaultProps = {\n    gutterType: 'default',\n    optimizeSelection: false,\n    selectedChanges: [],\n    widgets: {},\n    className: '',\n    renderToken: undefined,\n    renderGutter({renderDefault, wrapInAnchor}) {\n        return wrapInAnchor(renderDefault());\n    },\n    generateAnchorID() {\n        return undefined;\n    },\n    children(hunks) {\n        const key = hunk => `-${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines}`;\n        return hunks.map(hunk => <Hunk key={key(hunk)} hunk={hunk} />);\n    },\n};\n\nexport default memo(Diff);\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n","import {Children} from 'react';\nimport classNames from 'classnames';\n\nconst SplitDecoration = ({hideGutter, monotonous, className, gutterClassName, contentClassName, children}) => {\n    const computedClassName = classNames('diff-decoration', className);\n    const computedGutterClassName = classNames('diff-decoration-gutter', gutterClassName);\n    const computedContentClassName = classNames('diff-decoration-content', contentClassName);\n    const columnCount = (hideGutter ? 2 : 4) / (monotonous ? 2 : 1);\n    const headerContentColSpan = columnCount - (hideGutter ? 0 : 1);\n\n    // One element spans all gutter and content cells\n    if (Children.count(children) === 1) {\n        return (\n            <tbody className={computedClassName}>\n                <tr>\n                    <td colSpan={columnCount} className={computedContentClassName}>\n                        {children}\n                    </td>\n                </tr>\n            </tbody>\n        );\n    }\n\n    const [gutter, content] = children;\n\n    return (\n        <tbody className={computedClassName}>\n            <tr>\n                {!hideGutter && <td className={computedGutterClassName}>{gutter}</td>}\n                <td colSpan={headerContentColSpan} className={computedContentClassName}>{content}</td>\n            </tr>\n        </tbody>\n    );\n};\n\nexport default SplitDecoration;\n","import {Children} from 'react';\nimport classNames from 'classnames';\n\nconst UnifiedDecoration = ({hideGutter, className, gutterClassName, contentClassName, children}) => {\n    const computedClassName = classNames('diff-decoration', className);\n    const computedGutterClassName = classNames('diff-decoration-gutter', gutterClassName);\n    const computedContentClassName = classNames('diff-decoration-content', contentClassName);\n\n    // One element spans all gutter and content cells\n    if (Children.count(children) === 1) {\n        return (\n            <tbody className={computedClassName}>\n                <tr>\n                    <td colSpan={hideGutter ? 1 : 3} className={computedContentClassName}>\n                        {children}\n                    </td>\n                </tr>\n            </tbody>\n        );\n    }\n\n    const [gutter, content] = children;\n\n    return (\n        <tbody className={computedClassName}>\n            <tr>\n                {!hideGutter && <td colSpan={2} className={computedGutterClassName}>{gutter}</td>}\n                <td className={computedContentClassName}>{content}</td>\n            </tr>\n        </tbody>\n    );\n};\n\nexport default UnifiedDecoration;\n","import {Children} from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport {useDiffSettings} from '../context';\nimport SplitDecoration from './SplitDecoration';\nimport UnifiedDecoration from './UnifiedDecoration';\n\nconst Decoration = props => {\n    const childrenCount = Children.count(props.children);\n\n    warning(\n        childrenCount <= 2,\n        'Decoration only accepts a maxium of 2 children'\n    );\n\n    warning(\n        childrenCount < 2 || !props.hideGutter,\n        'Gutter element in decoration will not be rendered since hideGutter prop is set to true'\n    );\n\n    const {viewType, gutterType, monotonous} = useDiffSettings();\n    const RenderingDecoration = viewType === 'split' ? SplitDecoration : UnifiedDecoration;\n\n    return (\n        <RenderingDecoration\n            hideGutter={gutterType === 'none'}\n            monotonous={monotonous}\n            {...props}\n        />\n    );\n};\n\nDecoration.propTypes = {\n    className: PropTypes.string,\n    gutterClassName: PropTypes.string,\n    contentClassName: PropTypes.string,\n    children: PropTypes.node.isRequired,\n};\n\nDecoration.defaultProps = {\n    className: '',\n    gutterClassName: '',\n    contentClassName: '',\n};\n\nexport default Decoration;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","/**\n * The function whose prototype chain sequence wrappers inherit from.\n *\n * @private\n */\nfunction baseLodash() {\n  // No operation performed.\n}\n\nmodule.exports = baseLodash;\n","var baseCreate = require('./_baseCreate'),\n    baseLodash = require('./_baseLodash');\n\n/**\n * The base constructor for creating `lodash` wrapper objects.\n *\n * @private\n * @param {*} value The value to wrap.\n * @param {boolean} [chainAll] Enable explicit method chain sequences.\n */\nfunction LodashWrapper(value, chainAll) {\n  this.__wrapped__ = value;\n  this.__actions__ = [];\n  this.__chain__ = !!chainAll;\n  this.__index__ = 0;\n  this.__values__ = undefined;\n}\n\nLodashWrapper.prototype = baseCreate(baseLodash.prototype);\nLodashWrapper.prototype.constructor = LodashWrapper;\n\nmodule.exports = LodashWrapper;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","var flatten = require('./flatten'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nmodule.exports = flatRest;\n","var WeakMap = require('./_WeakMap');\n\n/** Used to store function metadata. */\nvar metaMap = WeakMap && new WeakMap;\n\nmodule.exports = metaMap;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var metaMap = require('./_metaMap'),\n    noop = require('./noop');\n\n/**\n * Gets metadata for `func`.\n *\n * @private\n * @param {Function} func The function to query.\n * @returns {*} Returns the metadata for `func`.\n */\nvar getData = !metaMap ? noop : function(func) {\n  return metaMap.get(func);\n};\n\nmodule.exports = getData;\n","/** Used to lookup unminified function names. */\nvar realNames = {};\n\nmodule.exports = realNames;\n","var realNames = require('./_realNames');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the name of `func`.\n *\n * @private\n * @param {Function} func The function to query.\n * @returns {string} Returns the function name.\n */\nfunction getFuncName(func) {\n  var result = (func.name + ''),\n      array = realNames[result],\n      length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n  while (length--) {\n    var data = array[length],\n        otherFunc = data.func;\n    if (otherFunc == null || otherFunc == func) {\n      return data.name;\n    }\n  }\n  return result;\n}\n\nmodule.exports = getFuncName;\n","var baseCreate = require('./_baseCreate'),\n    baseLodash = require('./_baseLodash');\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295;\n\n/**\n * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n *\n * @private\n * @constructor\n * @param {*} value The value to wrap.\n */\nfunction LazyWrapper(value) {\n  this.__wrapped__ = value;\n  this.__actions__ = [];\n  this.__dir__ = 1;\n  this.__filtered__ = false;\n  this.__iteratees__ = [];\n  this.__takeCount__ = MAX_ARRAY_LENGTH;\n  this.__views__ = [];\n}\n\n// Ensure `LazyWrapper` is an instance of `baseLodash`.\nLazyWrapper.prototype = baseCreate(baseLodash.prototype);\nLazyWrapper.prototype.constructor = LazyWrapper;\n\nmodule.exports = LazyWrapper;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var LazyWrapper = require('./_LazyWrapper'),\n    LodashWrapper = require('./_LodashWrapper'),\n    copyArray = require('./_copyArray');\n\n/**\n * Creates a clone of `wrapper`.\n *\n * @private\n * @param {Object} wrapper The wrapper to clone.\n * @returns {Object} Returns the cloned wrapper.\n */\nfunction wrapperClone(wrapper) {\n  if (wrapper instanceof LazyWrapper) {\n    return wrapper.clone();\n  }\n  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n  result.__actions__ = copyArray(wrapper.__actions__);\n  result.__index__  = wrapper.__index__;\n  result.__values__ = wrapper.__values__;\n  return result;\n}\n\nmodule.exports = wrapperClone;\n","var LazyWrapper = require('./_LazyWrapper'),\n    LodashWrapper = require('./_LodashWrapper'),\n    baseLodash = require('./_baseLodash'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike'),\n    wrapperClone = require('./_wrapperClone');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates a `lodash` object which wraps `value` to enable implicit method\n * chain sequences. Methods that operate on and return arrays, collections,\n * and functions can be chained together. Methods that retrieve a single value\n * or may return a primitive value will automatically end the chain sequence\n * and return the unwrapped value. Otherwise, the value must be unwrapped\n * with `_#value`.\n *\n * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n * enabled using `_.chain`.\n *\n * The execution of chained methods is lazy, that is, it's deferred until\n * `_#value` is implicitly or explicitly called.\n *\n * Lazy evaluation allows several methods to support shortcut fusion.\n * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n * the creation of intermediate arrays and can greatly reduce the number of\n * iteratee executions. Sections of a chain sequence qualify for shortcut\n * fusion if the section is applied to an array and iteratees accept only\n * one argument. The heuristic for whether a section qualifies for shortcut\n * fusion is subject to change.\n *\n * Chaining is supported in custom builds as long as the `_#value` method is\n * directly or indirectly included in the build.\n *\n * In addition to lodash methods, wrappers have `Array` and `String` methods.\n *\n * The wrapper `Array` methods are:\n * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n *\n * The wrapper `String` methods are:\n * `replace` and `split`\n *\n * The wrapper methods that support shortcut fusion are:\n * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n *\n * The chainable wrapper methods are:\n * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n * `zipObject`, `zipObjectDeep`, and `zipWith`\n *\n * The wrapper methods that are **not** chainable by default are:\n * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n * `upperFirst`, `value`, and `words`\n *\n * @name _\n * @constructor\n * @category Seq\n * @param {*} value The value to wrap in a `lodash` instance.\n * @returns {Object} Returns the new `lodash` wrapper instance.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * var wrapped = _([1, 2, 3]);\n *\n * // Returns an unwrapped value.\n * wrapped.reduce(_.add);\n * // => 6\n *\n * // Returns a wrapped value.\n * var squares = wrapped.map(square);\n *\n * _.isArray(squares);\n * // => false\n *\n * _.isArray(squares.value());\n * // => true\n */\nfunction lodash(value) {\n  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n    if (value instanceof LodashWrapper) {\n      return value;\n    }\n    if (hasOwnProperty.call(value, '__wrapped__')) {\n      return wrapperClone(value);\n    }\n  }\n  return new LodashWrapper(value);\n}\n\n// Ensure wrappers are instances of `baseLodash`.\nlodash.prototype = baseLodash.prototype;\nlodash.prototype.constructor = lodash;\n\nmodule.exports = lodash;\n","var LazyWrapper = require('./_LazyWrapper'),\n    getData = require('./_getData'),\n    getFuncName = require('./_getFuncName'),\n    lodash = require('./wrapperLodash');\n\n/**\n * Checks if `func` has a lazy counterpart.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n *  else `false`.\n */\nfunction isLaziable(func) {\n  var funcName = getFuncName(func),\n      other = lodash[funcName];\n\n  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n    return false;\n  }\n  if (func === other) {\n    return true;\n  }\n  var data = getData(other);\n  return !!data && func === data[0];\n}\n\nmodule.exports = isLaziable;\n","var LodashWrapper = require('./_LodashWrapper'),\n    flatRest = require('./_flatRest'),\n    getData = require('./_getData'),\n    getFuncName = require('./_getFuncName'),\n    isArray = require('./isArray'),\n    isLaziable = require('./_isLaziable');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to compose bitmasks for function metadata. */\nvar WRAP_CURRY_FLAG = 8,\n    WRAP_PARTIAL_FLAG = 32,\n    WRAP_ARY_FLAG = 128,\n    WRAP_REARG_FLAG = 256;\n\n/**\n * Creates a `_.flow` or `_.flowRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new flow function.\n */\nfunction createFlow(fromRight) {\n  return flatRest(function(funcs) {\n    var length = funcs.length,\n        index = length,\n        prereq = LodashWrapper.prototype.thru;\n\n    if (fromRight) {\n      funcs.reverse();\n    }\n    while (index--) {\n      var func = funcs[index];\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n        var wrapper = new LodashWrapper([], true);\n      }\n    }\n    index = wrapper ? index : length;\n    while (++index < length) {\n      func = funcs[index];\n\n      var funcName = getFuncName(func),\n          data = funcName == 'wrapper' ? getData(func) : undefined;\n\n      if (data && isLaziable(data[0]) &&\n            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n            !data[4].length && data[9] == 1\n          ) {\n        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n      } else {\n        wrapper = (func.length == 1 && isLaziable(func))\n          ? wrapper[funcName]()\n          : wrapper.thru(func);\n      }\n    }\n    return function() {\n      var args = arguments,\n          value = args[0];\n\n      if (wrapper && args.length == 1 && isArray(value)) {\n        return wrapper.plant(value).value();\n      }\n      var index = 0,\n          result = length ? funcs[index].apply(this, args) : value;\n\n      while (++index < length) {\n        result = funcs[index].call(this, result);\n      }\n      return result;\n    };\n  });\n}\n\nmodule.exports = createFlow;\n","var createFlow = require('./_createFlow');\n\n/**\n * Creates a function that returns the result of invoking the given functions\n * with the `this` binding of the created function, where each successive\n * invocation is supplied the return value of the previous.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Util\n * @param {...(Function|Function[])} [funcs] The functions to invoke.\n * @returns {Function} Returns the new composite function.\n * @see _.flowRight\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * var addSquare = _.flow([_.add, square]);\n * addSquare(1, 2);\n * // => 9\n */\nvar flow = createFlow();\n\nmodule.exports = flow;\n","/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayAggregator;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var baseEach = require('./_baseEach');\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseAggregator;\n","var arrayAggregator = require('./_arrayAggregator'),\n    baseAggregator = require('./_baseAggregator'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nmodule.exports = createAggregator;\n","var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The corresponding value of\n * each key is the last element responsible for generating the key. The\n * iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * var array = [\n *   { 'dir': 'left', 'code': 97 },\n *   { 'dir': 'right', 'code': 100 }\n * ];\n *\n * _.keyBy(array, function(o) {\n *   return String.fromCharCode(o.code);\n * });\n * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n *\n * _.keyBy(array, 'dir');\n * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n */\nvar keyBy = createAggregator(function(result, value, key) {\n  baseAssignValue(result, key, value);\n});\n\nmodule.exports = keyBy;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var baseFlatten = require('./_baseFlatten'),\n    map = require('./map');\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nmodule.exports = flatMap;\n","import {flatMap, last, keyBy} from 'lodash';\nimport {computeOldLineNumber, computeNewLineNumber} from '../utils';\n\n// This function mutates `linesOfCode` argument.\nconst applyHunk = (linesOfCode, {newStart, changes}) => {\n    // Within each hunk, changes are continous, so we can use a sequential algorithm here.\n    //\n    // When `linesOfCode` is received here, it has already patched by previous hunk,\n    // thus the starting line number has changed due to possible unbanlanced deletions and insertions,\n    // we should use `newStart` as the first line number of current reduce.\n    const [patchedLines] = changes.reduce(\n        ([lines, cursor], {content, isInsert, isDelete}) => {\n            if (isDelete) {\n                lines.splice(cursor, 1);\n                return [lines, cursor];\n            }\n\n            if (isInsert) {\n                lines.splice(cursor, 0, content);\n            }\n            return [lines, cursor + 1];\n        },\n        [linesOfCode, newStart - 1]\n    );\n\n    return patchedLines;\n};\n\nconst applyDiff = (oldSource, hunks) => {\n    // `hunks` must be ordered here.\n    const patchedLines = hunks.reduce(applyHunk, oldSource.split('\\n'));\n    return patchedLines.join('\\n');\n};\n\nconst mapChanges = (changes, side, toValue) => {\n    if (!changes.length) {\n        return [];\n    }\n\n    const computeLineNumber = side === 'old' ? computeOldLineNumber : computeNewLineNumber;\n    const changesByLineNumber = keyBy(changes, computeLineNumber);\n    const maxLineNumber = computeLineNumber(last(changes));\n    return Array.from({length: maxLineNumber}).map((value, i) => toValue(changesByLineNumber[i + 1]));\n};\n\nconst groupChanges = hunks => {\n    const changes = flatMap(hunks, hunk => hunk.changes);\n    return changes.reduce(\n        ([oldChanges, newChanges], change) => {\n            if (change.isNormal) {\n                oldChanges.push(change);\n                newChanges.push(change);\n            }\n            else if (change.isDelete) {\n                oldChanges.push(change);\n            }\n            else {\n                newChanges.push(change);\n            }\n\n            return [oldChanges, newChanges];\n        },\n        [[], []]\n    );\n};\n\nconst toTextPair = hunks => {\n    const [oldChanges, newChanges] = groupChanges(hunks);\n    const toText = change => (change ? change.content : '');\n    const oldText = mapChanges(oldChanges, 'old', toText).join('\\n');\n    const newText = mapChanges(newChanges, 'new', toText).join('\\n');\n\n    return [oldText, newText];\n};\n\nconst createRoot = children => ({type: 'root', children: children});\n\nexport default (hunks, {highlight, refractor, oldSource, language}) => {\n    if (oldSource) {\n        const newSource = applyDiff(oldSource, hunks);\n        const highlightText = highlight\n            ? (text, language) => refractor.highlight(text, language)\n            : text => [{type: 'text', value: text}];\n\n        return [\n            createRoot(highlightText(oldSource, language)),\n            createRoot(highlightText(newSource, language)),\n        ];\n    }\n\n    const textPair = toTextPair(hunks);\n    const toTree = highlight\n        ? text => createRoot(refractor.highlight(text, language))\n        : text => createRoot([{type: 'text', value: text}]);\n\n    return textPair.map(toTree);\n};\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var baseGet = require('./_baseGet'),\n    baseSlice = require('./_baseSlice');\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nmodule.exports = parent;\n","var castPath = require('./_castPath'),\n    last = require('./last'),\n    parent = require('./_parent'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = castPath(path, object);\n  object = parent(object, path);\n  return object == null || delete object[toKey(last(path))];\n}\n\nmodule.exports = baseUnset;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var isPlainObject = require('./isPlainObject');\n\n/**\n * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n * objects.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} key The key of the property to inspect.\n * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n */\nfunction customOmitClone(value) {\n  return isPlainObject(value) ? undefined : value;\n}\n\nmodule.exports = customOmitClone;\n","var arrayMap = require('./_arrayMap'),\n    baseClone = require('./_baseClone'),\n    baseUnset = require('./_baseUnset'),\n    castPath = require('./_castPath'),\n    copyObject = require('./_copyObject'),\n    customOmitClone = require('./_customOmitClone'),\n    flatRest = require('./_flatRest'),\n    getAllKeysIn = require('./_getAllKeysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */\nvar omit = flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = arrayMap(paths, function(path) {\n    path = castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  copyObject(object, getAllKeysIn(object), result);\n  if (isDeep) {\n    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    baseUnset(result, paths[length]);\n  }\n  return result;\n});\n\nmodule.exports = omit;\n","import {last} from 'lodash';\n\nexport const clone = path => path.map(node => ({...node}));\n\nexport const replace = (path, leaf) => [...clone(path.slice(0, -1)), leaf];\n\nexport const wrap = (path, parent) => [parent, ...clone(path)];\n\nexport const split = (path, splitStart, splitEnd, wrapSplitNode) => {\n    const parents = path.slice(0, -1);\n    const leaf = last(path);\n    const output = [];\n\n    if (splitEnd <= 0 || splitStart >= leaf.value.length) {\n        return [path];\n    }\n\n    const split = (start, end) => {\n        const value = leaf.value.slice(start, end);\n        return [...parents, {...leaf, value}];\n    };\n\n    if (splitStart > 0) {\n        const head = split(0, splitStart);\n        output.push(clone(head));\n    }\n\n    const body = split(Math.max(splitStart, 0), splitEnd);\n    output.push(wrapSplitNode ? wrap(body, wrapSplitNode) : clone(body));\n\n    if (splitEnd < leaf.value.length) {\n        const tail = split(splitEnd);\n        output.push(clone(tail));\n    }\n\n    return output;\n};\n","import {last, omit} from 'lodash';\nimport {clone, replace} from './utils';\n\nconst treeToPathList = (node, output = [], path = []) => {\n    const nodeToUse = omit(node, 'children');\n\n    if (node.children) {\n        path.push(nodeToUse);\n        for (const child of node.children) {\n            treeToPathList(child, output, path);\n        }\n        path.pop();\n    }\n    else {\n        output.push(clone([...path.slice(1), nodeToUse]));\n    }\n\n    return output;\n};\n\nconst splitPathToLines = path => {\n    const leaf = last(path);\n\n    if (!leaf.value.includes('\\n')) {\n        return [path];\n    }\n\n    const linesOfText = leaf.value.split('\\n');\n    return linesOfText.map(line => replace(path, {...leaf, value: line}));\n};\n\nconst splitByLineBreak = paths => paths.reduce(\n    (lines, path) => {\n        const currentLine = last(lines);\n        const [currentRemaining, ...nextLines] = splitPathToLines(path);\n        return [\n            ...lines.slice(0, -1),\n            [...currentLine, currentRemaining],\n            ...nextLines.map(path => [path]),\n        ];\n    },\n    [[]]\n);\n\nexport default tree => {\n    const paths = treeToPathList(tree);\n    const linesOfPaths = splitByLineBreak(paths);\n    return linesOfPaths;\n};\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","import {last, isEqual, omit} from 'lodash';\n\nconst areNodesMeregable = (x, y) => {\n    if (x.type !== y.type) {\n        return false;\n    }\n\n    if (x.type === 'text') {\n        return true;\n    }\n\n    if (!x.children || !y.children) {\n        return false;\n    }\n\n    const xBase = 'children' in x ? omit(x, 'children') : x;\n    const yBase = 'children' in y ? omit(y, 'children') : y;\n\n    return isEqual(xBase, yBase);\n};\n\nconst mergeNode = (x, y) => {\n    if ('value' in x) {\n        return {\n            ...x,\n            value: x.value + y.value,\n        };\n    }\n\n    return x;\n};\n\nconst attachNode = (parent, node) => {\n    const previousSibling = last(parent.children);\n\n    if (previousSibling && areNodesMeregable(previousSibling, node)) {\n        /* eslint-disable no-param-reassign */\n        parent.children[parent.children.length - 1] = mergeNode(previousSibling, node);\n        /* eslint-enable no-param-reassign */\n    }\n    else {\n        parent.children.push(node);\n    }\n\n    return last(parent.children);\n};\n\nexport default pathList => {\n    const root = {type: 'root', children: []};\n\n    for (const path of pathList) {\n        path.reduce(\n            (parent, node, i) => {\n                const nodeToUse = i === path.length - 1 ? {...node} : {...node, children: []};\n                return attachNode(parent, nodeToUse);\n            },\n            root\n        );\n    }\n\n    return root;\n};\n","var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nmodule.exports = groupBy;\n","var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n","/**\n * @file 在高亮的语法节点上插入代码定义与引用的信息\n * @author zhanglili\n */\n\nimport {last, isEmpty, groupBy} from 'lodash';\nimport {split} from './utils';\n\nconst splitPathToEncloseRange = (paths, node) => {\n    const {start, length, properties} = node;\n    const rangeEnd = start + length;\n    const [output] = paths.reduce(\n        ([output, nodeStart], path) => {\n            const leaf = last(path);\n            const nodeEnd = nodeStart + leaf.value.length;\n\n            if (nodeStart > rangeEnd || nodeEnd < start) {\n                output.push(path);\n            }\n            else {\n                // it should be just node in next major release\n                const wrapNode = {...node, ...properties};\n                const segments = split(path, start - nodeStart, rangeEnd - nodeStart, wrapNode);\n                output.push(...segments);\n            }\n\n            return [output, nodeEnd];\n        },\n        [[], 0]\n    );\n\n    return output;\n};\n\nconst pickRangesFromPath = (paths, ranges) => {\n    if (isEmpty(ranges)) {\n        return paths;\n    }\n\n    return ranges.reduce(splitPathToEncloseRange, paths);\n};\n\nconst process = (linesOfPaths, ranges) => {\n    const rangesByLine = groupBy(ranges, 'lineNumber');\n    return linesOfPaths.map((line, i) => pickRangesFromPath(line, rangesByLine[i + 1]));\n};\n\nexport default (oldRanges, newRanges) => ([oldLinesOfPaths, newLinesOfPaths]) => [\n    process(oldLinesOfPaths, oldRanges),\n    process(newLinesOfPaths, newRanges),\n];\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nfunction diff_match_patch() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff_match_patch.Diff;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix]);\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] = patch.diffs[y].slice();\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding]);\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push([DIFF_EQUAL, precontext]);\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push([diff_type, diff_text]);\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push([diff_type, diff_text]);\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line]);\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line]);\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line]);\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emmulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indicies are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;","import {findIndex, flatMap, last, flatten} from 'lodash';\nimport DiffMatchPatch from 'diff-match-patch';\nimport pickRanges from './pickRanges';\n\nconst {DIFF_EQUAL, DIFF_DELETE, DIFF_INSERT} = DiffMatchPatch;\n\nconst findChangeBlocks = changes => {\n    const start = findIndex(changes, change => !change.isNormal);\n\n    if (start === -1) {\n        return [];\n    }\n\n    const end = findIndex(changes, change => change.isNormal, start);\n\n    if (end === -1) {\n        return [changes.slice(start)];\n    }\n\n    return [\n        changes.slice(start, end),\n        ...findChangeBlocks(changes.slice(end)),\n    ];\n};\n\nconst groupDiffs = diffs => diffs.reduce(\n    ([oldDiffs, newDiffs], diff) => {\n        const [type] = diff;\n\n        switch (type) {\n            case DIFF_INSERT:\n                newDiffs.push(diff);\n                break;\n            case DIFF_DELETE:\n                oldDiffs.push(diff);\n                break;\n            default:\n                oldDiffs.push(diff);\n                newDiffs.push(diff);\n                break;\n        }\n\n        return [oldDiffs, newDiffs];\n    },\n    [[], []]\n);\n\nconst splitDiffToLines = diffs => diffs.reduce(\n    (lines, [type, value]) => {\n        const currentLines = value.split('\\n');\n\n        const [currentLineRemaining, ...nextLines] = currentLines.map(line => [type, line]);\n        const next = [\n            ...lines.slice(0, -1),\n            [...last(lines), currentLineRemaining],\n            ...nextLines.map(line => [line]),\n        ];\n        return next;\n    },\n    [[]]\n);\n\nconst diffsToEdits = (diffs, lineNumber) => {\n    const output = diffs.reduce(\n        (output, diff) => {\n            const [edits, start] = output;\n            const [type, value] = diff;\n            if (type !== DIFF_EQUAL) {\n                const edit = {\n                    type: 'edit',\n                    lineNumber: lineNumber,\n                    start: start,\n                    length: value.length,\n                };\n                edits.push(edit);\n            }\n\n            return [edits, start + value.length];\n        },\n        [[], 0]\n    );\n\n    return output[0];\n};\n\nconst convertToLinesOfEdits = (linesOfDiffs, startLineNumber) => flatMap(\n    linesOfDiffs,\n    (diffs, i) => diffsToEdits(diffs, startLineNumber + i)\n);\n\nconst diffText = (x, y) => {\n    const dmp = new DiffMatchPatch();\n    const diffs = dmp.diff_main(x, y);\n    dmp.diff_cleanupSemantic(diffs);\n\n    if (diffs.length <= 1) {\n        return [[], []];\n    }\n\n    return groupDiffs(diffs);\n};\n\nconst diffChangeBlock = changes => {\n    const [oldSource, newSource] = changes.reduce(\n        ([oldSource, newSource], {isDelete, content}) => (\n            isDelete\n                ? [oldSource + (oldSource ? '\\n' : '') + content, newSource]\n                : [oldSource, newSource + (newSource ? '\\n' : '') + content]\n        ),\n        ['', '']\n    );\n\n    const [oldDiffs, newDiffs] = diffText(oldSource, newSource);\n\n    if (oldDiffs.length === 0 && newDiffs.length === 0) {\n        return [oldDiffs, newDiffs];\n    }\n\n    const getLineNumber = change => change && change.lineNumber;\n    const oldStartLineNumber = getLineNumber(changes.find(change => change.isDelete));\n    const newStartLineNumber = getLineNumber(changes.find(change => change.isInsert));\n    const oldEdits = convertToLinesOfEdits(splitDiffToLines(oldDiffs), oldStartLineNumber);\n    const newEdits = convertToLinesOfEdits(splitDiffToLines(newDiffs), newStartLineNumber);\n\n    return [oldEdits, newEdits];\n};\n\nconst diffByLine = changes => changes.reduce(\n    ([oldEdits, newEdits, previousChange], currentChange) => {\n        if (!previousChange.isDelete || !currentChange.isInsert) {\n            return [oldEdits, newEdits, currentChange];\n        }\n\n        const [oldDiffs, newDiffs] = diffText(previousChange.content, currentChange.content);\n        return [\n            oldEdits.concat(diffsToEdits(oldDiffs, previousChange.lineNumber)),\n            newEdits.concat(diffsToEdits(newDiffs, currentChange.lineNumber)),\n            currentChange,\n        ];\n    },\n    [[], [], {}]\n);\n\nexport default (hunks, {type = 'block'} = {}) => {\n    const changeBlocks = flatMap(hunks.map(hunk => hunk.changes), findChangeBlocks);\n    const findEdits = type === 'block' ? diffChangeBlock : diffByLine;\n\n    const [oldEdits, newEdits] = changeBlocks.map(findEdits).reduce(\n        ([oldEdits, newEdits], [currentOld, currentNew]) => [\n            oldEdits.concat(currentOld),\n            newEdits.concat(currentNew),\n        ],\n        [[], []]\n    );\n\n    return pickRanges(flatten(oldEdits), flatten(newEdits));\n};\n","import {flatMap, last} from 'lodash';\nimport {replace} from './utils';\n\nconst markInPaths = (word, name, replacement) => paths => flatMap(\n    paths,\n    path => {\n        const leaf = last(path);\n\n        if (!leaf.value.includes(word)) {\n            return [path];\n        }\n\n        const segments = leaf.value.split(word);\n\n        return segments.reduce(\n            (output, text, i) => {\n                if (i !== 0) {\n                    output.push(replace(path, {type: 'mark', markType: name, value: replacement}));\n                }\n\n                if (text) {\n                    output.push(replace(path, {...leaf, value: text}));\n                }\n\n                return output;\n            },\n            []\n        );\n    }\n);\n\nexport default (word, name, replacement = word) => {\n    const mark = markInPaths(word, name, replacement);\n\n    return ([oldLinesOfPaths, newLinesOfPaths]) => [\n        oldLinesOfPaths.map(mark),\n        newLinesOfPaths.map(mark),\n    ];\n};\n","import {flow} from 'lodash';\nimport toTokenTrees from './toTokenTrees';\nimport normalizeToLines from './normalizeToLines';\nimport backToTree from './backToTree';\n\nexport const tokenize = (hunks, options) => {\n    const {\n        highlight = false,\n        refractor,\n        oldSource,\n        language,\n        enhancers = [],\n    } = options;\n\n    const tokenTreesPair = toTokenTrees(hunks, {highlight, refractor, oldSource, language});\n    const linesOfPathsPair = tokenTreesPair.map(normalizeToLines);\n\n    const enhance = flow(enhancers);\n    const enhancedLinesOfPathsPair = enhance(linesOfPathsPair);\n    const [oldTrees, newTrees] = enhancedLinesOfPathsPair.map(paths => paths.map(backToTree));\n    return {\n        old: oldTrees.map(root => root.children),\n        new: newTrees.map(root => root.children),\n    };\n};\n\nexport pickRanges from './pickRanges';\n\nexport markEdits from './markEdits';\n\nexport markWord from './markWord';\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar createChangeEmitter = exports.createChangeEmitter = function createChangeEmitter() {\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  function listen(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function () {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  function emit() {\n    currentListeners = nextListeners;\n    var listeners = currentListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].apply(listeners, arguments);\n    }\n  }\n\n  return {\n    listen: listen,\n    emit: emit\n  };\n};","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","import React, { createFactory, Component, createElement } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport shallowEqual from 'fbjs/lib/shallowEqual';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport { polyfill } from 'react-lifecycles-compat';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { createChangeEmitter } from 'change-emitter';\nimport $$observable from 'symbol-observable';\n\nvar setStatic = function setStatic(key, value) {\n  return function (BaseComponent) {\n    /* eslint-disable no-param-reassign */\n    BaseComponent[key] = value;\n    /* eslint-enable no-param-reassign */\n\n    return BaseComponent;\n  };\n};\n\nvar setDisplayName = function setDisplayName(displayName) {\n  return setStatic('displayName', displayName);\n};\n\nvar getDisplayName = function getDisplayName(Component$$1) {\n  if (typeof Component$$1 === 'string') {\n    return Component$$1;\n  }\n\n  if (!Component$$1) {\n    return undefined;\n  }\n\n  return Component$$1.displayName || Component$$1.name || 'Component';\n};\n\nvar wrapDisplayName = function wrapDisplayName(BaseComponent, hocName) {\n  return hocName + \"(\" + getDisplayName(BaseComponent) + \")\";\n};\n\nvar mapProps = function mapProps(propsMapper) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var MapProps = function MapProps(props) {\n      return factory(propsMapper(props));\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'mapProps'))(MapProps);\n    }\n\n    return MapProps;\n  };\n};\n\nvar withProps = function withProps(input) {\n  var hoc = mapProps(function (props) {\n    return _extends({}, props, typeof input === 'function' ? input(props) : input);\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    return function (BaseComponent) {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'withProps'))(hoc(BaseComponent));\n    };\n  }\n\n  return hoc;\n};\n\nvar pick = function pick(obj, keys) {\n  var result = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result;\n};\n\nvar withPropsOnChange = function withPropsOnChange(shouldMapOrKeys, propsMapper) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n    var shouldMap = typeof shouldMapOrKeys === 'function' ? shouldMapOrKeys : function (props, nextProps) {\n      return !shallowEqual(pick(props, shouldMapOrKeys), pick(nextProps, shouldMapOrKeys));\n    };\n\n    var WithPropsOnChange =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(WithPropsOnChange, _Component);\n\n      function WithPropsOnChange() {\n        var _this;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n        _this.state = {\n          computedProps: propsMapper(_this.props),\n          prevProps: _this.props\n        };\n        return _this;\n      }\n\n      WithPropsOnChange.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n        if (shouldMap(prevState.prevProps, nextProps)) {\n          return {\n            computedProps: propsMapper(nextProps),\n            prevProps: nextProps\n          };\n        }\n\n        return {\n          prevProps: nextProps\n        };\n      };\n\n      var _proto = WithPropsOnChange.prototype;\n\n      _proto.render = function render() {\n        return factory(_extends({}, this.props, this.state.computedProps));\n      };\n\n      return WithPropsOnChange;\n    }(Component);\n\n    polyfill(WithPropsOnChange);\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'withPropsOnChange'))(WithPropsOnChange);\n    }\n\n    return WithPropsOnChange;\n  };\n};\n\nvar mapValues = function mapValues(obj, func) {\n  var result = {};\n  /* eslint-disable no-restricted-syntax */\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      result[key] = func(obj[key], key);\n    }\n  }\n  /* eslint-enable no-restricted-syntax */\n\n\n  return result;\n};\n\nvar withHandlers = function withHandlers(handlers) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var WithHandlers =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(WithHandlers, _Component);\n\n      function WithHandlers() {\n        var _this;\n\n        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n          _args[_key] = arguments[_key];\n        }\n\n        _this = _Component.call.apply(_Component, [this].concat(_args)) || this;\n        _this.handlers = mapValues(typeof handlers === 'function' ? handlers(_this.props) : handlers, function (createHandler) {\n          return function () {\n            var handler = createHandler(_this.props);\n\n            if (process.env.NODE_ENV !== 'production' && typeof handler !== 'function') {\n              console.error( // eslint-disable-line no-console\n              'withHandlers(): Expected a map of higher-order functions. ' + 'Refer to the docs for more info.');\n            }\n\n            return handler.apply(void 0, arguments);\n          };\n        });\n        return _this;\n      }\n\n      var _proto = WithHandlers.prototype;\n\n      _proto.render = function render() {\n        return factory(_extends({}, this.props, this.handlers));\n      };\n\n      return WithHandlers;\n    }(Component);\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'withHandlers'))(WithHandlers);\n    }\n\n    return WithHandlers;\n  };\n};\n\nvar defaultProps = function defaultProps(props) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var DefaultProps = function DefaultProps(ownerProps) {\n      return factory(ownerProps);\n    };\n\n    DefaultProps.defaultProps = props;\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'defaultProps'))(DefaultProps);\n    }\n\n    return DefaultProps;\n  };\n};\n\nvar omit = function omit(obj, keys) {\n  var rest = _extends({}, obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (rest.hasOwnProperty(key)) {\n      delete rest[key];\n    }\n  }\n\n  return rest;\n};\n\nvar renameProp = function renameProp(oldName, newName) {\n  var hoc = mapProps(function (props) {\n    var _extends2;\n\n    return _extends({}, omit(props, [oldName]), (_extends2 = {}, _extends2[newName] = props[oldName], _extends2));\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    return function (BaseComponent) {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'renameProp'))(hoc(BaseComponent));\n    };\n  }\n\n  return hoc;\n};\n\nvar keys = Object.keys;\n\nvar mapKeys = function mapKeys(obj, func) {\n  return keys(obj).reduce(function (result, key) {\n    var val = obj[key];\n    /* eslint-disable no-param-reassign */\n\n    result[func(val, key)] = val;\n    /* eslint-enable no-param-reassign */\n\n    return result;\n  }, {});\n};\n\nvar renameProps = function renameProps(nameMap) {\n  var hoc = mapProps(function (props) {\n    return _extends({}, omit(props, keys(nameMap)), mapKeys(pick(props, keys(nameMap)), function (_, oldName) {\n      return nameMap[oldName];\n    }));\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    return function (BaseComponent) {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'renameProps'))(hoc(BaseComponent));\n    };\n  }\n\n  return hoc;\n};\n\nvar flattenProp = function flattenProp(propName) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var FlattenProp = function FlattenProp(props) {\n      return factory(_extends({}, props, props[propName]));\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'flattenProp'))(FlattenProp);\n    }\n\n    return FlattenProp;\n  };\n};\n\nvar withState = function withState(stateName, stateUpdaterName, initialState) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var WithState =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(WithState, _Component);\n\n      function WithState() {\n        var _this;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n        _this.state = {\n          stateValue: typeof initialState === 'function' ? initialState(_this.props) : initialState\n        };\n\n        _this.updateStateValue = function (updateFn, callback) {\n          return _this.setState(function (_ref) {\n            var stateValue = _ref.stateValue;\n            return {\n              stateValue: typeof updateFn === 'function' ? updateFn(stateValue) : updateFn\n            };\n          }, callback);\n        };\n\n        return _this;\n      }\n\n      var _proto = WithState.prototype;\n\n      _proto.render = function render() {\n        var _extends2;\n\n        return factory(_extends({}, this.props, (_extends2 = {}, _extends2[stateName] = this.state.stateValue, _extends2[stateUpdaterName] = this.updateStateValue, _extends2)));\n      };\n\n      return WithState;\n    }(Component);\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'withState'))(WithState);\n    }\n\n    return WithState;\n  };\n};\n\nvar withStateHandlers = function withStateHandlers(initialState, stateUpdaters) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var WithStateHandlers =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(WithStateHandlers, _Component);\n\n      function WithStateHandlers() {\n        var _this;\n\n        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n          _args[_key] = arguments[_key];\n        }\n\n        _this = _Component.call.apply(_Component, [this].concat(_args)) || this;\n        _this.state = typeof initialState === 'function' ? initialState(_this.props) : initialState;\n        _this.stateUpdaters = mapValues(stateUpdaters, function (handler) {\n          return function (mayBeEvent) {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n\n            // Having that functional form of setState can be called async\n            // we need to persist SyntheticEvent\n            if (mayBeEvent && typeof mayBeEvent.persist === 'function') {\n              mayBeEvent.persist();\n            }\n\n            _this.setState(function (state, props) {\n              return handler(state, props).apply(void 0, [mayBeEvent].concat(args));\n            });\n          };\n        });\n        return _this;\n      }\n\n      var _proto = WithStateHandlers.prototype;\n\n      _proto.render = function render() {\n        return factory(_extends({}, this.props, this.state, this.stateUpdaters));\n      };\n\n      return WithStateHandlers;\n    }(Component);\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'withStateHandlers'))(WithStateHandlers);\n    }\n\n    return WithStateHandlers;\n  };\n};\n\nvar noop = function noop() {};\n\nvar withReducer = function withReducer(stateName, dispatchName, reducer, initialState) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var WithReducer =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(WithReducer, _Component);\n\n      function WithReducer() {\n        var _this;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n        _this.state = {\n          stateValue: _this.initializeStateValue()\n        };\n\n        _this.dispatch = function (action, callback) {\n          if (callback === void 0) {\n            callback = noop;\n          }\n\n          return _this.setState(function (_ref) {\n            var stateValue = _ref.stateValue;\n            return {\n              stateValue: reducer(stateValue, action)\n            };\n          }, function () {\n            return callback(_this.state.stateValue);\n          });\n        };\n\n        return _this;\n      }\n\n      var _proto = WithReducer.prototype;\n\n      _proto.initializeStateValue = function initializeStateValue() {\n        if (initialState !== undefined) {\n          return typeof initialState === 'function' ? initialState(this.props) : initialState;\n        }\n\n        return reducer(undefined, {\n          type: '@@recompose/INIT'\n        });\n      };\n\n      _proto.render = function render() {\n        var _extends2;\n\n        return factory(_extends({}, this.props, (_extends2 = {}, _extends2[stateName] = this.state.stateValue, _extends2[dispatchName] = this.dispatch, _extends2)));\n      };\n\n      return WithReducer;\n    }(Component);\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'withReducer'))(WithReducer);\n    }\n\n    return WithReducer;\n  };\n};\n\nvar identity = function identity(Component$$1) {\n  return Component$$1;\n};\n\nvar branch = function branch(test, left, right) {\n  if (right === void 0) {\n    right = identity;\n  }\n\n  return function (BaseComponent) {\n    var leftFactory;\n    var rightFactory;\n\n    var Branch = function Branch(props) {\n      if (test(props)) {\n        leftFactory = leftFactory || createFactory(left(BaseComponent));\n        return leftFactory(props);\n      }\n\n      rightFactory = rightFactory || createFactory(right(BaseComponent));\n      return rightFactory(props);\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'branch'))(Branch);\n    }\n\n    return Branch;\n  };\n};\n\nvar renderComponent = function renderComponent(Component$$1) {\n  return function (_) {\n    var factory = createFactory(Component$$1);\n\n    var RenderComponent = function RenderComponent(props) {\n      return factory(props);\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      RenderComponent.displayName = wrapDisplayName(Component$$1, 'renderComponent');\n    }\n\n    return RenderComponent;\n  };\n};\n\nvar Nothing =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Nothing, _Component);\n\n  function Nothing() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Nothing.prototype;\n\n  _proto.render = function render() {\n    return null;\n  };\n\n  return Nothing;\n}(Component);\n\nvar renderNothing = function renderNothing(_) {\n  return Nothing;\n};\n\nvar shouldUpdate = function shouldUpdate(test) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var ShouldUpdate =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(ShouldUpdate, _Component);\n\n      function ShouldUpdate() {\n        return _Component.apply(this, arguments) || this;\n      }\n\n      var _proto = ShouldUpdate.prototype;\n\n      _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n        return test(this.props, nextProps);\n      };\n\n      _proto.render = function render() {\n        return factory(this.props);\n      };\n\n      return ShouldUpdate;\n    }(Component);\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'shouldUpdate'))(ShouldUpdate);\n    }\n\n    return ShouldUpdate;\n  };\n};\n\nvar pure = function pure(BaseComponent) {\n  var hoc = shouldUpdate(function (props, nextProps) {\n    return !shallowEqual(props, nextProps);\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    return setDisplayName(wrapDisplayName(BaseComponent, 'pure'))(hoc(BaseComponent));\n  }\n\n  return hoc(BaseComponent);\n};\n\nvar onlyUpdateForKeys = function onlyUpdateForKeys(propKeys) {\n  var hoc = shouldUpdate(function (props, nextProps) {\n    return !shallowEqual(pick(nextProps, propKeys), pick(props, propKeys));\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    return function (BaseComponent) {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'onlyUpdateForKeys'))(hoc(BaseComponent));\n    };\n  }\n\n  return hoc;\n};\n\nvar onlyUpdateForPropTypes = function onlyUpdateForPropTypes(BaseComponent) {\n  var propTypes = BaseComponent.propTypes;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!propTypes) {\n      /* eslint-disable */\n      console.error('A component without any `propTypes` was passed to ' + '`onlyUpdateForPropTypes()`. Check the implementation of the ' + (\"component with display name \\\"\" + getDisplayName(BaseComponent) + \"\\\".\"));\n      /* eslint-enable */\n    }\n  }\n\n  var propKeys = Object.keys(propTypes || {});\n  var OnlyUpdateForPropTypes = onlyUpdateForKeys(propKeys)(BaseComponent);\n\n  if (process.env.NODE_ENV !== 'production') {\n    return setDisplayName(wrapDisplayName(BaseComponent, 'onlyUpdateForPropTypes'))(OnlyUpdateForPropTypes);\n  }\n\n  return OnlyUpdateForPropTypes;\n};\n\nvar withContext = function withContext(childContextTypes, getChildContext) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var WithContext =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(WithContext, _Component);\n\n      function WithContext() {\n        var _this;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n\n        _this.getChildContext = function () {\n          return getChildContext(_this.props);\n        };\n\n        return _this;\n      }\n\n      var _proto = WithContext.prototype;\n\n      _proto.render = function render() {\n        return factory(this.props);\n      };\n\n      return WithContext;\n    }(Component);\n\n    WithContext.childContextTypes = childContextTypes;\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'withContext'))(WithContext);\n    }\n\n    return WithContext;\n  };\n};\n\nvar getContext = function getContext(contextTypes) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    var GetContext = function GetContext(ownerProps, context) {\n      return factory(_extends({}, ownerProps, context));\n    };\n\n    GetContext.contextTypes = contextTypes;\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'getContext'))(GetContext);\n    }\n\n    return GetContext;\n  };\n};\n\nvar lifecycle = function lifecycle(spec) {\n  return function (BaseComponent) {\n    var factory = createFactory(BaseComponent);\n\n    if (process.env.NODE_ENV !== 'production' && spec.hasOwnProperty('render')) {\n      console.error('lifecycle() does not support the render method; its behavior is to ' + 'pass all props and state to the base component.');\n    }\n\n    var Lifecycle =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(Lifecycle, _Component);\n\n      function Lifecycle() {\n        return _Component.apply(this, arguments) || this;\n      }\n\n      var _proto = Lifecycle.prototype;\n\n      _proto.render = function render() {\n        return factory(_extends({}, this.props, this.state));\n      };\n\n      return Lifecycle;\n    }(Component);\n\n    Object.keys(spec).forEach(function (hook) {\n      return Lifecycle.prototype[hook] = spec[hook];\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'lifecycle'))(Lifecycle);\n    }\n\n    return Lifecycle;\n  };\n};\n\nvar isClassComponent = function isClassComponent(Component$$1) {\n  return Boolean(Component$$1 && Component$$1.prototype && typeof Component$$1.prototype.render === 'function');\n};\n\nvar toClass = function toClass(baseComponent) {\n  var _class, _temp;\n\n  return isClassComponent(baseComponent) ? baseComponent : (_temp = _class =\n  /*#__PURE__*/\n  function (_Component) {\n    _inheritsLoose(ToClass, _Component);\n\n    function ToClass() {\n      return _Component.apply(this, arguments) || this;\n    }\n\n    var _proto = ToClass.prototype;\n\n    _proto.render = function render() {\n      if (typeof baseComponent === 'string') {\n        return React.createElement(baseComponent, this.props);\n      }\n\n      return baseComponent(this.props, this.context);\n    };\n\n    return ToClass;\n  }(Component), _class.displayName = getDisplayName(baseComponent), _class.propTypes = baseComponent.propTypes, _class.contextTypes = baseComponent.contextTypes, _class.defaultProps = baseComponent.defaultProps, _temp);\n};\n\nfunction toRenderProps(hoc) {\n  var RenderPropsComponent = function RenderPropsComponent(props) {\n    return props.children(props);\n  };\n\n  return hoc(RenderPropsComponent);\n}\n\nvar fromRenderProps = function fromRenderProps(RenderPropsComponent, propsMapper, renderPropName) {\n  if (renderPropName === void 0) {\n    renderPropName = 'children';\n  }\n\n  return function (BaseComponent) {\n    var baseFactory = React.createFactory(BaseComponent);\n    var renderPropsFactory = React.createFactory(RenderPropsComponent);\n\n    var FromRenderProps = function FromRenderProps(ownerProps) {\n      var _renderPropsFactory;\n\n      return renderPropsFactory((_renderPropsFactory = {}, _renderPropsFactory[renderPropName] = function () {\n        return baseFactory(_extends({}, ownerProps, propsMapper.apply(void 0, arguments)));\n      }, _renderPropsFactory));\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'fromRenderProps'))(FromRenderProps);\n    }\n\n    return FromRenderProps;\n  };\n};\n\nvar setPropTypes = function setPropTypes(propTypes) {\n  return setStatic('propTypes', propTypes);\n};\n\nvar compose = function compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  }, function (arg) {\n    return arg;\n  });\n};\n\nvar createSink = function createSink(callback) {\n  var Sink =\n  /*#__PURE__*/\n  function (_Component) {\n    _inheritsLoose(Sink, _Component);\n\n    function Sink() {\n      var _this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n      _this.state = {};\n      return _this;\n    }\n\n    Sink.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps) {\n      callback(nextProps);\n      return null;\n    };\n\n    var _proto = Sink.prototype;\n\n    _proto.render = function render() {\n      return null;\n    };\n\n    return Sink;\n  }(Component);\n\n  polyfill(Sink);\n  return Sink;\n};\n\nvar componentFromProp = function componentFromProp(propName) {\n  var Component$$1 = function Component$$1(props) {\n    return createElement(props[propName], omit(props, [propName]));\n  };\n\n  Component$$1.displayName = \"componentFromProp(\" + propName + \")\";\n  return Component$$1;\n};\n\nvar nest = function nest() {\n  for (var _len = arguments.length, Components = new Array(_len), _key = 0; _key < _len; _key++) {\n    Components[_key] = arguments[_key];\n  }\n\n  var factories = Components.map(createFactory);\n\n  var Nest = function Nest(_ref) {\n    var children = _ref.children,\n        props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n    return factories.reduceRight(function (child, factory) {\n      return factory(props, child);\n    }, children);\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    var displayNames = Components.map(getDisplayName);\n    Nest.displayName = \"nest(\" + displayNames.join(', ') + \")\";\n  }\n\n  return Nest;\n};\n\nvar hoistStatics = function hoistStatics(higherOrderComponent, blacklist) {\n  return function (BaseComponent) {\n    var NewComponent = higherOrderComponent(BaseComponent);\n    hoistNonReactStatics(NewComponent, BaseComponent, blacklist);\n    return NewComponent;\n  };\n};\n\nvar _config = {\n  fromESObservable: null,\n  toESObservable: null\n};\n\nvar configureObservable = function configureObservable(c) {\n  _config = c;\n};\n\nvar config = {\n  fromESObservable: function fromESObservable(observable) {\n    return typeof _config.fromESObservable === 'function' ? _config.fromESObservable(observable) : observable;\n  },\n  toESObservable: function toESObservable(stream) {\n    return typeof _config.toESObservable === 'function' ? _config.toESObservable(stream) : stream;\n  }\n};\n\nvar componentFromStreamWithConfig = function componentFromStreamWithConfig(config$$1) {\n  return function (propsToVdom) {\n    return (\n      /*#__PURE__*/\n      function (_Component) {\n        _inheritsLoose(ComponentFromStream, _Component);\n\n        function ComponentFromStream() {\n          var _config$fromESObserva;\n\n          var _this;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n          _this.state = {\n            vdom: null\n          };\n          _this.propsEmitter = createChangeEmitter();\n          _this.props$ = config$$1.fromESObservable((_config$fromESObserva = {\n            subscribe: function subscribe(observer) {\n              var unsubscribe = _this.propsEmitter.listen(function (props) {\n                if (props) {\n                  observer.next(props);\n                } else {\n                  observer.complete();\n                }\n              });\n\n              return {\n                unsubscribe: unsubscribe\n              };\n            }\n          }, _config$fromESObserva[$$observable] = function () {\n            return this;\n          }, _config$fromESObserva));\n          _this.vdom$ = config$$1.toESObservable(propsToVdom(_this.props$));\n          return _this;\n        }\n\n        var _proto = ComponentFromStream.prototype;\n\n        _proto.componentWillMount = function componentWillMount() {\n          var _this2 = this;\n\n          // Subscribe to child prop changes so we know when to re-render\n          this.subscription = this.vdom$.subscribe({\n            next: function next(vdom) {\n              _this2.setState({\n                vdom: vdom\n              });\n            }\n          });\n          this.propsEmitter.emit(this.props);\n        };\n\n        _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n          // Receive new props from the owner\n          this.propsEmitter.emit(nextProps);\n        };\n\n        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n          return nextState.vdom !== this.state.vdom;\n        };\n\n        _proto.componentWillUnmount = function componentWillUnmount() {\n          // Call without arguments to complete stream\n          this.propsEmitter.emit(); // Clean-up subscription before un-mounting\n\n          this.subscription.unsubscribe();\n        };\n\n        _proto.render = function render() {\n          return this.state.vdom;\n        };\n\n        return ComponentFromStream;\n      }(Component)\n    );\n  };\n};\n\nvar componentFromStream = function componentFromStream(propsToVdom) {\n  return componentFromStreamWithConfig(config)(propsToVdom);\n};\n\nvar identity$1 = function identity(t) {\n  return t;\n};\n\nvar mapPropsStreamWithConfig = function mapPropsStreamWithConfig(config$$1) {\n  var componentFromStream$$1 = componentFromStreamWithConfig({\n    fromESObservable: identity$1,\n    toESObservable: identity$1\n  });\n  return function (transform) {\n    return function (BaseComponent) {\n      var factory = createFactory(BaseComponent);\n      var fromESObservable = config$$1.fromESObservable,\n          toESObservable = config$$1.toESObservable;\n      return componentFromStream$$1(function (props$) {\n        var _ref;\n\n        return _ref = {\n          subscribe: function subscribe(observer) {\n            var subscription = toESObservable(transform(fromESObservable(props$))).subscribe({\n              next: function next(childProps) {\n                return observer.next(factory(childProps));\n              }\n            });\n            return {\n              unsubscribe: function unsubscribe() {\n                return subscription.unsubscribe();\n              }\n            };\n          }\n        }, _ref[$$observable] = function () {\n          return this;\n        }, _ref;\n      });\n    };\n  };\n};\n\nvar mapPropsStream = function mapPropsStream(transform) {\n  var hoc = mapPropsStreamWithConfig(config)(transform);\n\n  if (process.env.NODE_ENV !== 'production') {\n    return function (BaseComponent) {\n      return setDisplayName(wrapDisplayName(BaseComponent, 'mapPropsStream'))(hoc(BaseComponent));\n    };\n  }\n\n  return hoc;\n};\n\nvar createEventHandlerWithConfig = function createEventHandlerWithConfig(config$$1) {\n  return function () {\n    var _config$fromESObserva;\n\n    var emitter = createChangeEmitter();\n    var stream = config$$1.fromESObservable((_config$fromESObserva = {\n      subscribe: function subscribe(observer) {\n        var unsubscribe = emitter.listen(function (value) {\n          return observer.next(value);\n        });\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _config$fromESObserva[$$observable] = function () {\n      return this;\n    }, _config$fromESObserva));\n    return {\n      handler: emitter.emit,\n      stream: stream\n    };\n  };\n};\nvar createEventHandler = createEventHandlerWithConfig(config);\n\n// Higher-order component helpers\n\nexport { mapProps, withProps, withPropsOnChange, withHandlers, defaultProps, renameProp, renameProps, flattenProp, withState, withStateHandlers, withReducer, branch, renderComponent, renderNothing, shouldUpdate, pure, onlyUpdateForKeys, onlyUpdateForPropTypes, withContext, getContext, lifecycle, toClass, toRenderProps, fromRenderProps, setStatic, setPropTypes, setDisplayName, compose, getDisplayName, wrapDisplayName, shallowEqual, isClassComponent, createSink, componentFromProp, nest, hoistStatics, componentFromStream, componentFromStreamWithConfig, mapPropsStream, mapPropsStreamWithConfig, createEventHandler, createEventHandlerWithConfig, configureObservable as setObservableConfig };\n","import {useMemo} from 'react';\nimport {expandCollapsedBlockBy} from '../utils';\n\nexport default (minLinesExclusive, hunks, oldSource) => {\n    if (!oldSource) {\n        return hunks;\n    }\n\n    const renderingHunks = useMemo(\n        () => {\n            const predicate = lines => lines < minLinesExclusive;\n\n            return expandCollapsedBlockBy(hunks, oldSource, predicate);\n        },\n        [minLinesExclusive, hunks, oldSource]\n    );\n\n    return renderingHunks;\n};\n","import {useReducer, useRef} from 'react';\n\nconst updateCollection = (collection, {type, value}) => {\n    switch (type) {\n        case 'push':\n            return [...collection, value];\n        case 'clear':\n            return collection.length ? [] : collection;\n        case 'toggle':\n            return collection.includes(value)\n                ? collection.filter(item => item !== value)\n                : collection.concat(value);\n        case 'only':\n            return [value];\n        default:\n            return collection;\n    }\n};\n\nexport const useCollection = () => {\n    const [collection, dispatch] = useReducer(updateCollection, []);\n\n    return {\n        collection,\n        clear() {\n            dispatch({type: 'clear'});\n        },\n        push(value) {\n            dispatch({value, type: 'push'});\n        },\n        toggle(value) {\n            dispatch({value, type: 'toggle'});\n        },\n        only(value) {\n            dispatch({value, type: 'only'});\n        },\n    };\n};\n\n// This is actually a hack around the lack of custom comparator support in `useEffect` hook.\nexport const useCustomEqualIdentifier = (value, equals) => {\n    const cache = useRef({});\n    const identifier = useRef(0);\n    const isEqual = equals(value, cache.current);\n\n    if (!isEqual) {\n        cache.current = value;\n        identifier.current = identifier.current + 1;\n    }\n\n    return identifier.current;\n};\n","import {useEffect} from 'react';\nimport {getChangeKey} from '../utils';\nimport {useCollection} from './helpers';\n\nexport default (hunks, {multiple = false} = {}) => {\n    const {collection, clear, toggle, only} = useCollection();\n    useEffect(clear, [hunks]);\n\n    return [\n        collection,\n        ({change}) => {\n            const changeKey = getChangeKey(change);\n            if (multiple) {\n                toggle(changeKey);\n            }\n            else {\n                only(changeKey);\n            }\n        },\n    ];\n};\n","import {useEffect, useMemo} from 'react';\nimport {expandFromRawCode} from '../utils';\nimport {useCollection} from './helpers';\n\nexport default (hunks, oldSource) => {\n    const {collection: expandedRanges, clear, push} = useCollection();\n    useEffect(clear, [hunks, oldSource]);\n    const linesOfOldSource = useMemo(() => (oldSource || '').split('\\n'), [oldSource]);\n    const renderingHunks = useMemo(\n        () => {\n            if (!linesOfOldSource.length) {\n                return hunks;\n            }\n\n            return expandedRanges.reduce(\n                (hunks, [start, end]) => expandFromRawCode(hunks, linesOfOldSource, start, end),\n                hunks\n            );\n        },\n        [linesOfOldSource, hunks, expandedRanges]\n    );\n\n    return [\n        renderingHunks,\n        (start, end) => push([start, end]),\n    ];\n};\n","'use strict';\n\nfunction shallowEqualObjects(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n\n  if (!objA || !objB) {\n    return false;\n  }\n\n  var aKeys = Object.keys(objA);\n  var bKeys = Object.keys(objB);\n  var len = aKeys.length;\n\n  if (bKeys.length !== len) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var key = aKeys[i];\n\n    if (objA[key] !== objB[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqualObjects;\n","'use strict';\n\nfunction shallowEqualArrays(arrA, arrB) {\n  if (arrA === arrB) {\n    return true;\n  }\n\n  if (!arrA || !arrB) {\n    return false;\n  }\n\n  var len = arrA.length;\n\n  if (arrB.length !== len) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (arrA[i] !== arrB[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqualArrays;\n","import {useState, useRef, useEffect} from 'react';\nimport shallowEquals from 'shallow-equal/objects';\nimport arrayShallowEquals from 'shallow-equal/arrays';\nimport {flatMap} from 'lodash';\nimport {useCustomEqualIdentifier} from './helpers';\n\nconst uid = (() => {\n    let current = 0;\n\n    return () => {\n        current = current + 1;\n        return current;\n    };\n})();\n\nconst findAbnormalChanges = hunks => flatMap(hunks, hunk => hunk.changes.filter(change => !change.isNormal));\n\nconst areHunksEqual = (xHunks, yHunks) => {\n    const xChanges = findAbnormalChanges(xHunks);\n    const yChanges = findAbnormalChanges(yHunks);\n\n    return arrayShallowEquals(xChanges, yChanges);\n};\n\nconst defaultShouldTokenize = ({hunks: currentHunks, ...currentPayload}, {hunks: prevHunks, ...prevPayload}) => {\n    if (currentPayload.oldSource !== prevPayload.oldSource) {\n        return true;\n    }\n\n    // When `oldSource` is provided, we can get the new source by applying diff,\n    // so when hunks keep identical, the tokenize result will always remain the same.\n    if (currentPayload.oldSource) {\n        return !shallowEquals(currentPayload, prevPayload) || !areHunksEqual(currentHunks, prevHunks);\n    }\n\n    return currentHunks !== prevHunks || !shallowEquals(currentPayload, prevPayload);\n};\n\nexport default (worker, payload, options = {}) => {\n    const {shouldTokenize = defaultShouldTokenize} = options;\n    const payloadIdentifier = useCustomEqualIdentifier(\n        payload,\n        (current, previous) => !shouldTokenize(current, previous)\n    );\n    const [tokenizeResult, setTokenizeResult] = useState({tokens: null, tokenizationFailReason: null});\n    const job = useRef(null);\n    useEffect(\n        () => {\n            const receiveTokens = ({data: {payload, id}}) => {\n                if (id !== job.current) {\n                    return;\n                }\n\n                if (payload.success) {\n                    setTokenizeResult({tokens: payload.tokens, tokenizationFailReason: null});\n                }\n                else {\n                    setTokenizeResult({tokens: null, tokenizationFailReason: payload.reason});\n                }\n            };\n            worker.addEventListener('message', receiveTokens);\n            return () => worker.removeEventListener('message', receiveTokens);\n        },\n        [worker] // We don't really expect the worker to be changed in an application's lifecycle\n    );\n    useEffect(\n        () => {\n            job.current = uid();\n            const data = {\n                payload,\n                id: job.current,\n                type: 'tokenize',\n            };\n            worker.postMessage(data);\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [payloadIdentifier, worker, shouldTokenize] // TODO: How about worker changes when payload keeps identical?\n    );\n\n    return tokenizeResult;\n};\n","import {wrapDisplayName} from 'recompose';\nimport {useSourceExpansion} from '../hooks';\n\nexport default () => ComponentIn => {\n    const ComponentOut = props => {\n        const [renderingHunks, expandRange] = useSourceExpansion(props.hunks, props.oldSource);\n\n        return (\n            <ComponentIn\n                {...props}\n                hunks={renderingHunks}\n                onExpandRange={expandRange}\n            />\n        );\n    };\n\n    ComponentOut.displayName = wrapDisplayName(ComponentIn, 'withSourceExpansion');\n\n    return ComponentOut;\n};\n","import {wrapDisplayName} from 'recompose';\nimport {useMinCollapsedLines} from '../hooks';\n\nexport default minLinesExclusive => ComponentIn => {\n    const ComponentOut = props => {\n        const renderingHunks = useMinCollapsedLines(minLinesExclusive, props.hunks, props.oldSource);\n        return <ComponentIn {...props} hunks={renderingHunks} />;\n    };\n\n    ComponentOut.displayName = wrapDisplayName(ComponentIn, 'minCollapsedLines');\n\n    return ComponentOut;\n};\n","import {wrapDisplayName} from 'recompose';\nimport {useChangeSelect} from '../hooks';\n\nexport default options => ComponentIn => {\n    const ComponentOut = props => {\n        const [selectedChanges, toggleChangeSelection] = useChangeSelect(props.hunks, options);\n\n        return (\n            <ComponentIn\n                {...props}\n                selectedChanges={selectedChanges}\n                onToggleChangeSelection={toggleChangeSelection}\n            />\n        );\n    };\n\n    ComponentOut.displayName = wrapDisplayName(ComponentIn, 'withChangeSelect');\n\n    return ComponentOut;\n};\n","import {wrapDisplayName} from 'recompose';\nimport {useTokenizeWorker} from '../hooks';\n\nconst defaultMapPayload = data => {\n    return data;\n};\n\nexport default (worker, options = {}) => {\n    const {mapPayload = defaultMapPayload, ...hookOptions} = options;\n\n    const resolveMessagePayload = props => {\n        const {hunks, oldSource, language} = props;\n        const input = {\n            language: language,\n            oldSource: oldSource,\n            hunks: hunks,\n        };\n        return mapPayload(input, props);\n    };\n\n    return ComponentIn => {\n        const ComponentOut = props => {\n            const payload = resolveMessagePayload(props);\n            const tokenizationResult = useTokenizeWorker(worker, payload, hookOptions);\n\n            return <ComponentIn {...props} {...tokenizationResult} />;\n        };\n\n        ComponentOut.displayName = wrapDisplayName(ComponentIn, 'withTokenizeWorker');\n\n        return ComponentOut;\n    };\n};\n"],"names":["hasOwn","hasOwnProperty","classNames","classes","i","arguments","length","arg","argType","push","Array","isArray","inner","apply","key","call","join","module","exports","default","window","ContextType","createContext","Provider","useDiffSettings","useContext","first","array","last","sideToProperty","side","computeLineNumberFactory","isNormal","isInsert","lineNumber","oldLineNumber","isDelete","newLineNumber","isInHunkFactory","startProperty","linesProperty","hunk","start","end","isBetweenHunksFactory","previousHunk","nextHunk","findContainerHunkFactory","isInHunk","hunks","find","findChangeByLineNumberFactory","computeLineNumber","findContainerHunk","containerHunk","changes","change","getCorrespondingLineNumberFactory","baseSide","anotherSide","baseStart","baseLines","correspondingStart","correspondingLines","baseLineNumber","correspondingLineNumber","isBetweenHunks","firstHunk","spanFromStart","lastHunk","spanFromEnd","currentHunk","changeIndex","findIndex","possibleCorrespondingChangeIndex","possibleCorrespondingChange","negativeChangeType","type","Error","baseFindIndex","predicate","fromIndex","fromRight","index","listCacheClear","this","__data__","size","eq","value","other","assocIndexOf","arrayProto","prototype","splice","listCacheDelete","data","pop","listCacheGet","undefined","listCacheHas","listCacheSet","ListCache","entries","clear","entry","set","get","has","stackClear","stackDelete","result","stackGet","stackHas","freeGlobal","global","Object","freeSelf","self","root","Function","Symbol","objectProto","nativeObjectToString","toString","symToStringTag","toStringTag","getRawTag","isOwn","tag","unmasked","e","objectToString","nullTag","undefinedTag","baseGetTag","isObject","asyncTag","funcTag","genTag","proxyTag","isFunction","coreJsData","maskSrcKey","uid","exec","keys","IE_PROTO","isMasked","func","funcProto","funcToString","toSource","reRegExpChar","reIsHostCtor","reIsNative","RegExp","replace","baseIsNative","test","getValue","object","getNative","Map","nativeCreate","hashClear","hashDelete","HASH_UNDEFINED","hashGet","hashHas","hashSet","Hash","mapCacheClear","hash","map","string","isKeyable","getMapData","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","LARGE_ARRAY_SIZE","stackSet","pairs","Stack","setCacheAdd","setCacheHas","SetCache","values","add","arraySome","cacheHas","cache","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","equalArrays","bitmask","customizer","equalFunc","stack","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","othIndex","Uint8Array","mapToArray","forEach","setToArray","boolTag","dateTag","errorTag","mapTag","numberTag","regexpTag","setTag","stringTag","symbolTag","arrayBufferTag","dataViewTag","symbolProto","symbolValueOf","valueOf","equalByTag","byteLength","byteOffset","buffer","name","message","convert","arrayPush","offset","baseGetAllKeys","keysFunc","symbolsFunc","arrayFilter","resIndex","stubArray","propertyIsEnumerable","nativeGetSymbols","getOwnPropertySymbols","getSymbols","symbol","baseTimes","n","iteratee","isObjectLike","argsTag","baseIsArguments","isArguments","stubFalse","freeExports","nodeType","freeModule","Buffer","isBuffer","MAX_SAFE_INTEGER","reIsUint","isIndex","isLength","arrayTag","objectTag","weakMapTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","typedArrayTags","baseIsTypedArray","baseUnary","freeProcess","process","nodeUtil","types","require","binding","nodeIsTypedArray","isTypedArray","arrayLikeKeys","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","isPrototype","Ctor","constructor","overArg","transform","nativeKeys","baseKeys","isArrayLike","getAllKeys","equalObjects","objProps","objLength","skipCtor","objValue","objCtor","othCtor","DataView","Promise","Set","WeakMap","promiseTag","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","ctorString","baseIsEqualDeep","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","baseIsEqual","baseIsMatch","source","matchData","noCustomizer","srcValue","isStrictComparable","getMatchData","matchesStrictComparable","baseMatches","isSymbol","reIsDeepProp","reIsPlainProp","isKey","FUNC_ERROR_TEXT","memoize","resolver","TypeError","memoized","args","Cache","MAX_MEMOIZE_SIZE","memoizeCapped","rePropName","reEscapeChar","stringToPath","charCodeAt","match","number","quote","subString","arrayMap","INFINITY","symbolToString","baseToString","castPath","toKey","baseGet","path","defaultValue","baseHasIn","hasPath","hasFunc","hasIn","baseMatchesProperty","identity","baseProperty","basePropertyDeep","property","baseIteratee","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","toNumber","isBinary","slice","MAX_INTEGER","toFinite","toInteger","remainder","nativeMax","Math","max","nativeMin","min","findLastIndex","computeOldLineNumber","computeNewLineNumber","getOldRangeFromHunk","oldStart","oldLines","createHunkFromChanges","reduce","isPlain","newLines","newStart","content","textLinesToHunk","lines","oldStartLineNumber","newStartLineNumber","line","sliceHunk","startOldLineNumber","endOldLineNumber","startIndex","nearestHeadingNocmalChangeIndex","_findLastIndex","slicedChanges","endIndex","mergeHunk","previousStart","previousEnd","nextStart","nextEnd","head","tail","appendOrMergeHunk","concat","mergedHunk","insertHunk","insertion","insertionOldLineNumber","insertPosition","getCorrespondingNewLineNumber","isOldLineNumberInHunk","isOldLineNumberBetweenHunks","findCorrespondingValidHunkIndex","findNearestNormalChangeIndex","splitRangeToValidOnes","correspondingHunkIndex","correspondingHunk","headingChangesCount","validEnd","nearestNormalChangeIndex","validStartChange","validStart","adjacentChangesCount","expandCodeByValidRange","rawCodeOrLines","slicedLines","split","slicedHunk","expandFromRawCode","range","getCollapsedLinesCountBetween","expandCollapsedBlockBy","linesOfCode","initialExpandingBlocks","expandingBlocks","getChangeKey","findChangeByOldLineNumber","findChangeByNewLineNumber","getCorrespondingOldLineNumber","parser","parse","currentInfo","changeOldLine","changeNewLine","infos","stat","linesLen","indexOf","oldEndingNewLine","newEndingNewLine","simiLine","currentInfoType","nextLine","oldMode","newMode","similarity","simiLoop","spaceIndex","infoType","segs","revs","oldRevision","newRevision","infoStr","oldPath","newPath","typeChar","lastChange","zipChanges","current","lastDeletionIndex","mapHunk","options","nearbySequences","mapFile","file","normalizeDiffText","text","indexOfFirstLineBreak","indexOfSecondLineBreak","firstLine","secondLine","parseDiff","diffText","trim","files","defineProperty","baseAssignValue","configurable","enumerable","writable","createBaseFor","iterable","props","baseFor","baseForOwn","mapValues","defaultRenderToken","markType","properties","className","children","renderWithClassName","React","legacyClassName","CodeCell","tokens","renderToken","attributes","actualRenderToken","token","propTypes","PropTypes","isRequired","arrayOf","defaultProps","memo","renderDefaultBy","wrapInAnchorBy","gutterAnchor","anchorTarget","element","href","composeCallback","own","custom","useBoundCallbacks","callbacks","hoverOn","hoverOff","useMemo","output","_mapValues","fn","onMouseEnter","onMouseLeave","useBoolean","useState","setValue","useCallback","renderGutterCell","events","inHoverState","renderGutter","gutterOptions","renderDefault","wrapInAnchor","UnifiedChange","selected","gutterClassName","codeClassName","gutterEvents","codeEvents","hideGutter","generateAnchorID","hover","eventArg","boundGutterEvents","boundCodeEvents","anchorID","gutterClassNameValue","codeClassNameValue","id","bool","UnifiedWidget","colSpan","groupElements","widgets","elements","widget","renderRow","selectedChanges","lineClassName","changeProps","tokensOfLine","includes","UnifiedHunk","childrenProps","SIDE_OLD","SIDE_NEW","useCallbackOnSide","setHover","customCallbacks","markHover","unmarkHover","renderCells","gutterAnchorTarget","sideName","gutterProps","SplitChange","oldChange","newChange","oldSelected","newSelected","oldTokens","newTokens","monotonous","oldGutterEvents","newGutterEvents","oldCodeEvents","newCodeEvents","oldAnchorID","newAnchorID","commons","oldArgs","newArgs","lineTypeClassName","SplitWidget","oldElement","newElement","keyForPair","x","y","findWidget","next","rowChanges","oldWidget","newWidget","oldValue","newValue","old","SplitHunk","item","Hunk","gutterType","context","RenderingHunk","viewType","oneOf","shape","contentClassName","noop","findClosest","target","document","classList","contains","parentNode","setUserSelectStyle","selectable","style","userSelect","Diff","useRef","enableColumnSelection","button","closestCell","getSelection","removeAllRanges","_toConsumableArray","querySelectorAll","cells","diffType","optimizeSelection","remainings","onTableMouseDown","cols","ref","onMouseDown","objectOf","node","__DEV__","env","NODE_ENV","warning","printWarning","format","len","argIndex","console","error","condition","SplitDecoration","computedClassName","computedGutterClassName","computedContentClassName","columnCount","headerContentColSpan","Children","count","gutter","UnifiedDecoration","Decoration","childrenCount","RenderingDecoration","objectCreate","create","baseCreate","proto","baseLodash","LodashWrapper","chainAll","__wrapped__","__actions__","__chain__","__index__","__values__","spreadableSymbol","isConcatSpreadable","isFlattenable","baseFlatten","depth","isStrict","flatten","thisArg","overRest","otherArgs","constant","baseSetToString","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","shortOut","lastCalled","stamp","remaining","setToString","flatRest","metaMap","getData","realNames","getFuncName","otherFunc","MAX_ARRAY_LENGTH","LazyWrapper","__dir__","__filtered__","__iteratees__","__takeCount__","__views__","copyArray","wrapperClone","wrapper","clone","lodash","isLaziable","funcName","WRAP_CURRY_FLAG","WRAP_PARTIAL_FLAG","WRAP_ARY_FLAG","WRAP_REARG_FLAG","createFlow","funcs","prereq","thru","reverse","plant","flow","arrayAggregator","setter","accumulator","createBaseEach","eachFunc","collection","baseEach","baseAggregator","createAggregator","initializer","keyBy","baseMap","flatMap","applyHunk","cursor","applyDiff","oldSource","mapChanges","toValue","changesByLineNumber","_keyBy","maxLineNumber","_last","from","groupChanges","_flatMap","oldChanges","newChanges","toTextPair","toText","createRoot","highlight","refractor","language","newSource","highlightText","toTree","arrayEach","assignValue","copyObject","isNew","baseAssign","nativeKeysIn","baseKeysIn","isProto","keysIn","baseAssignIn","allocUnsafe","isDeep","copy","copySymbols","getPrototype","getPrototypeOf","getSymbolsIn","copySymbolsIn","getAllKeysIn","initCloneArray","input","cloneArrayBuffer","arrayBuffer","cloneDataView","dataView","reFlags","cloneRegExp","regexp","lastIndex","cloneSymbol","cloneTypedArray","typedArray","initCloneByTag","initCloneObject","baseIsMap","nodeIsMap","isMap","baseIsSet","nodeIsSet","isSet","CLONE_DEEP_FLAG","CLONE_FLAT_FLAG","CLONE_SYMBOLS_FLAG","cloneableTags","baseClone","isFlat","isFull","isFunc","cloneBuffer","subValue","baseSlice","parent","baseUnset","objectCtorString","isPlainObject","customOmitClone","omit","paths","leaf","wrap","splitStart","splitEnd","wrapSplitNode","parents","body","treeToPathList","nodeToUse","_omit","child","splitPathToLines","splitByLineBreak","currentLine","currentRemaining","nextLines","tree","isEqual","areNodesMeregable","xBase","yBase","_isEqual","mergeNode","attachNode","previousSibling","pathList","groupBy","isEmpty","splitPathToEncloseRange","rangeEnd","nodeStart","nodeEnd","wrapNode","segments","pickRangesFromPath","ranges","_isEmpty","linesOfPaths","rangesByLine","_groupBy","oldRanges","newRanges","oldLinesOfPaths","newLinesOfPaths","diff_match_patch","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","diff_main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","getTime","deadline","checklines","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","diffs","diff_compute_","unshift","diff_cleanupMerge","longtext","shorttext","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","diff_lineMode_","diff_bisect_","a","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","j","text1_length","text2_length","max_d","ceil","v_offset","v_length","v1","v2","delta","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","y1","x1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","fromCharCode","pointermin","pointermax","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","diff_cleanupSemanticLossless","deletion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","op","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","param","decodeURI","ex","isNaN","match_main","match_bitap_","s","match_alphabet_","match_bitapScore_","accuracy","proximity","abs","score_threshold","best_loc","lastIndexOf","bin_min","bin_mid","matchmask","last_rd","bin_max","finish","rd","charMatch","patch_addContext_","patch","start2","length1","padding","prefix","suffix","start1","length2","patch_make","opt_b","opt_c","patches","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","index2","index1","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","empty","shift","postcontext","patch_toText","patch_fromText","textline","textPointer","patchHeader","m","sign","DIFF_EQUAL","DiffMatchPatch","DIFF_DELETE","DIFF_INSERT","findChangeBlocks","_findIndex","groupDiffs","diff","oldDiffs","newDiffs","splitDiffToLines","currentLineRemaining","diffsToEdits","edits","convertToLinesOfEdits","linesOfDiffs","startLineNumber","diffChangeBlock","getLineNumber","diffByLine","currentChange","oldEdits","newEdits","previousChange","changeBlocks","findEdits","currentOld","currentNew","pickRanges","_flatten","markInPaths","word","replacement","mark","tokenize","enhancers","linesOfPathsPair","toTokenTrees","normalizeToLines","_flow","enhance","backToTree","oldTrees","newTrees","currentListeners","nextListeners","ensureCanMutateNextListeners","listen","listener","isSubscribed","emit","listeners","symbolObservablePonyfill","observable","ponyfill","getDisplayName","Component$$1","displayName","wrapDisplayName","BaseComponent","hocName","minLinesExclusive","updateCollection","filter","useCollection","useReducer","dispatch","toggle","only","useCustomEqualIdentifier","equals","identifier","multiple","useEffect","changeKey","expandedRanges","linesOfOldSource","shallowEqualObjects","objA","objB","aKeys","bKeys","shallowEqualArrays","arrA","arrB","findAbnormalChanges","areHunksEqual","xHunks","yHunks","xChanges","yChanges","arrayShallowEquals","defaultShouldTokenize","currentHunks","currentPayload","prevHunks","prevPayload","shallowEquals","worker","payload","shouldTokenize","payloadIdentifier","previous","tokenizationFailReason","tokenizeResult","setTokenizeResult","job","receiveTokens","success","reason","addEventListener","removeEventListener","postMessage","ComponentIn","ComponentOut","useSourceExpansion","renderingHunks","expandRange","onExpandRange","useMinCollapsedLines","useChangeSelect","toggleChangeSelection","onToggleChangeSelection","defaultMapPayload","mapPayload","hookOptions","resolveMessagePayload","tokenizationResult","useTokenizeWorker"],"mappings":"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"}